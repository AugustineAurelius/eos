//Code generated by generator, DO NOT EDIT.
package repository

import (
	sq "github.com/Masterminds/squirrel"
	"sort"
	common "github.com/AugustineAurelius/eos/example/common"
    "github.com/google/uuid"
)


type CommandRepository struct{
	db common.Querier
}

type QueryRepository struct{
	db common.Querier
}

func NewCommand(db common.Querier) *CommandRepository {
	return &CommandRepository{
		db: db,
	}
}

func NewQuery(db common.Querier) *QueryRepository {
	return &QueryRepository{
		db: db,
	}
}

// UserFiler represents the User filter.
type Filter struct {
  id *uuid.UUID
  notid *uuid.UUID
  gtid *uuid.UUID
  ltid *uuid.UUID
  gteqid *uuid.UUID
  lteqid *uuid.UUID
  ids []uuid.UUID
  name *string
  notname *string
  gtname *string
  ltname *string
  gteqname *string
  lteqname *string
  names []string
  email **string
  notemail **string
  gtemail **string
  ltemail **string
  gteqemail **string
  lteqemail **string
  emails []*string
}

type FilterOpt func(f *Filter)

func NewFilter(opts ...FilterOpt) Filter{
	f := &Filter{}
	for _, opt := range opts {
		opt(f)
	}
	return *f
}
func WithID(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.id = &id
	}
}
func WithIDNot(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.notid = &id
	}
}
func WithIDMoreThen(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.gtid = &id
	}
}
func WithIDLowerThen(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.ltid = &id
	}
}
func WithIDMoreOrEqualThen(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.gteqid = &id
	}
}
func WithIDLowerOrEqualThen(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.lteqid = &id
	}
}
func WithIDs (ids ...uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.ids = append(f.ids, ids...)
	}
}
func WithName(name string)  FilterOpt {
	return func(f *Filter) {
		f.name = &name
	}
}
func WithNameNot(name string)  FilterOpt {
	return func(f *Filter) {
		f.notname = &name
	}
}
func WithNameMoreThen(name string)  FilterOpt {
	return func(f *Filter) {
		f.gtname = &name
	}
}
func WithNameLowerThen(name string)  FilterOpt {
	return func(f *Filter) {
		f.ltname = &name
	}
}
func WithNameMoreOrEqualThen(name string)  FilterOpt {
	return func(f *Filter) {
		f.gteqname = &name
	}
}
func WithNameLowerOrEqualThen(name string)  FilterOpt {
	return func(f *Filter) {
		f.lteqname = &name
	}
}
func WithNames (names ...string)  FilterOpt {
	return func(f *Filter) {
		f.names = append(f.names, names...)
	}
}
func WithEmail(email *string)  FilterOpt {
	return func(f *Filter) {
		f.email = &email
	}
}
func WithEmailNot(email *string)  FilterOpt {
	return func(f *Filter) {
		f.notemail = &email
	}
}
func WithEmailMoreThen(email *string)  FilterOpt {
	return func(f *Filter) {
		f.gtemail = &email
	}
}
func WithEmailLowerThen(email *string)  FilterOpt {
	return func(f *Filter) {
		f.ltemail = &email
	}
}
func WithEmailMoreOrEqualThen(email *string)  FilterOpt {
	return func(f *Filter) {
		f.gteqemail = &email
	}
}
func WithEmailLowerOrEqualThen(email *string)  FilterOpt {
	return func(f *Filter) {
		f.lteqemail = &email
	}
}
func WithEmails (emails ...*string)  FilterOpt {
	return func(f *Filter) {
		f.emails = append(f.emails, emails...)
	}
}

func ApplyWhere[B interface {
    Where(pred interface{}, args ...interface{}) B
}](b B,f Filter) B {
	if f.id != nil {
      b = b.Where(sq.Eq{ColumnUserID: *f.id})
    }
	if f.notid != nil {
      b = b.Where(sq.NotEq{ColumnUserID: *f.id})
    }
	if f.ltid != nil {
      b = b.Where(sq.Lt{ColumnUserID: *f.id})
    }
	if f.gtid != nil {
      b = b.Where(sq.Gt{ColumnUserID: *f.id})
    }
	if f.lteqid != nil {
      b = b.Where(sq.LtOrEq{ColumnUserID: *f.id})
    }
	if f.gteqid != nil {
      b = b.Where(sq.GtOrEq{ColumnUserID: *f.id})
    }
	if f.ids != nil {
      b = b.Where(sq.Eq{ColumnUserID: f.ids})
    }
	if f.name != nil {
      b = b.Where(sq.Eq{ColumnUserName: *f.name})
    }
	if f.notname != nil {
      b = b.Where(sq.NotEq{ColumnUserName: *f.name})
    }
	if f.ltname != nil {
      b = b.Where(sq.Lt{ColumnUserName: *f.name})
    }
	if f.gtname != nil {
      b = b.Where(sq.Gt{ColumnUserName: *f.name})
    }
	if f.lteqname != nil {
      b = b.Where(sq.LtOrEq{ColumnUserName: *f.name})
    }
	if f.gteqname != nil {
      b = b.Where(sq.GtOrEq{ColumnUserName: *f.name})
    }
	if f.names != nil {
      b = b.Where(sq.Eq{ColumnUserName: f.names})
    }
	if f.email != nil {
      b = b.Where(sq.Eq{ColumnUserEmail: *f.email})
    }
	if f.notemail != nil {
      b = b.Where(sq.NotEq{ColumnUserEmail: *f.email})
    }
	if f.ltemail != nil {
      b = b.Where(sq.Lt{ColumnUserEmail: *f.email})
    }
	if f.gtemail != nil {
      b = b.Where(sq.Gt{ColumnUserEmail: *f.email})
    }
	if f.lteqemail != nil {
      b = b.Where(sq.LtOrEq{ColumnUserEmail: *f.email})
    }
	if f.gteqemail != nil {
      b = b.Where(sq.GtOrEq{ColumnUserEmail: *f.email})
    }
	if f.emails != nil {
      b = b.Where(sq.Eq{ColumnUserEmail: f.emails})
    }
  return b
}

type UpdateOpt func(u *Update)

// UserUpdate represents the User update struct.
type Update struct {
  id *uuid.UUID
  name *string
  email **string
}

func NewUpdate(opts ...UpdateOpt) Update{
	u := &Update{}
	for _, opt := range opts {
		opt(u)
	}
	return *u
}
func WithUpdateID(id uuid.UUID)  UpdateOpt {
	return func(f *Update) {
		f.id = &id
	}
}
func WithUpdateName(name string)  UpdateOpt {
	return func(f *Update) {
		f.name = &name
	}
}
func WithUpdateEmail(email *string)  UpdateOpt {
	return func(f *Update) {
		f.email = &email
	}
}

func ApplySet[B interface {
    Set(column string, value interface{}) B
}] (b B, f Update) B {
	if f.id != nil {
      b = b.Set(ColumnUserID, *f.id)
    }
	if f.name != nil {
      b = b.Set(ColumnUserName, *f.name)
    }
	if f.email != nil {
      b = b.Set(ColumnUserEmail, *f.email)
    }

  return b
}

type Users []User
func (s Users) ToIDs ()  []uuid.UUID {
	output := make([]uuid.UUID, 0, len(s))
	for i := 0; i < len(s); i++{
    output = append(output, s[i].ID)
	}
	return output
}
func (s Users) ToNames ()  []string {
	output := make([]string, 0, len(s))
	for i := 0; i < len(s); i++{
    output = append(output, s[i].Name)
	}
	return output
}
func (s Users) ToEmails ()  []*string {
	output := make([]*string, 0, len(s))
	for i := 0; i < len(s); i++{
    output = append(output, s[i].Email)
	}
	return output
}
func (s Users) FindByID (finder uuid.UUID)  (User, bool) {
	for i := 0; i < len(s); i++{
		if s[i].ID  == finder {
			return s[i], true 
		}
	}
	return   User {}, false
}
func (s Users) FindByName (finder string)  (User, bool) {
	for i := 0; i < len(s); i++{
		if s[i].Name  == finder {
			return s[i], true 
		}
	}
	return   User {}, false
}
func (s Users) FindByEmail (finder *string)  (User, bool) {
	for i := 0; i < len(s); i++{
		if s[i].Email  == finder {
			return s[i], true 
		}
	}
	return   User {}, false
}
func (s Users) SortByName (asc bool)  Users {
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return s[i].Name < s[j].Name
		})
		return s
	}	
	sort.Slice(s, func(i, j int) bool {
		return s[i].Name > s[j].Name
	})
	return  s
}
func (s Users) SortByEmail (asc bool)  Users {
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return *s[i].Email < *s[j].Email
		})
		return s
	}	
	sort.Slice(s, func(i, j int) bool {
		return *s[i].Email > *s[j].Email
	})
	return  s
}




func (s Users) FilterFunc(f func(i User) bool)  Users {
	output := make(Users, 0, len(s))
	for i := 0; i < len(s); i++{ 
		if f(s[i]) {
			output = append(output, s[i])
		}
	}
	return output
}
func (s Users) GetFirstID()  (*uuid.UUID, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].ID, true
}
func (s Users) GetFirstName()  (*string, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].Name, true
}
func (s Users) GetFirstEmail()  (**string, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].Email, true
}



func (s Users) GetFirst()  (User, bool) {
	if len(s) < 1 {
		return User{}, false
	}
	return s[0], true
}


