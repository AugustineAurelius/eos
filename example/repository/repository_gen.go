//Code generated by generator, DO NOT EDIT.
package repository

import (
	"context"
	"database/sql"

	sq "github.com/Masterminds/squirrel"
  "github.com/google/uuid"
)

type querier interface {
    ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
    QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
    QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

type wildcard int

const (
	QuestionWildcard wildcard = iota + 1
	DollarWildcard
)

type CommandRepository struct{
	runner querier
  placeholder wildcard 
}

type QueryRepository struct{
	runner querier
  placeholder wildcard 
}

func NewCommand(db querier, wildcards ...wildcard) *CommandRepository {
  w := QuestionWildcard 
  if len(wildcards) >0 {
    w = wildcards[0]
  }

	return &CommandRepository{
		runner: db,
    placeholder: w,
	}
}

func NewQuery(db querier, wildcards ...wildcard) *QueryRepository {
  w := QuestionWildcard 
  if len(wildcards) >0 {
    w = wildcards[0]
  }

	return &QueryRepository{
	    runner: db,
      placeholder: w,
	}
}

// UserFiler represents the User filter.
type Filter struct {
	id *uuid.UUID
	notid *uuid.UUID
	gtid *uuid.UUID
	ltid *uuid.UUID
	gteqid *uuid.UUID
	lteqid *uuid.UUID
	ids []uuid.UUID
	idorderByAsc  *string
	idorderByDesc *string
	name *string
	notname *string
	gtname *string
	ltname *string
	gteqname *string
	lteqname *string
	names []string
	nameorderByAsc  *string
	nameorderByDesc *string
	email **string
	notemail **string
	gtemail **string
	ltemail **string
	gteqemail **string
	lteqemail **string
	emails []*string
	emailorderByAsc  *string
	emailorderByDesc *string
	balance *float64
	notbalance *float64
	gtbalance *float64
	ltbalance *float64
	gteqbalance *float64
	lteqbalance *float64
	balances []float64
	balanceorderByAsc  *string
	balanceorderByDesc *string
	limit *int
	offset *int

}

type FilterOpt func(f *Filter)

func NewFilter(opts ...FilterOpt) Filter{
	f := &Filter{}
	for _, opt := range opts {
		opt(f)
	}
	return *f
}

func WithLimit(limit int)  FilterOpt {
	return func(f *Filter) {
		f.limit = &limit
	}
}
func WithOffset(offset int)  FilterOpt {
	return func(f *Filter) {
		f.offset = &offset
	}
}
func WithID(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.id = &id
	}
}
func WithIDNot(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.notid = &id
	}
}
func WithIDMoreThen(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.gtid = &id
	}
}
func WithIDLowerThen(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.ltid = &id
	}
}
func WithIDMoreOrEqualThen(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.gteqid = &id
	}
}
func WithIDLowerOrEqualThen(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.lteqid = &id
	}
}
func WithIDs (ids ...uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.ids = append(f.ids, ids...)
	}
}

func WithOrderByIDAsc()  FilterOpt {
	return func(f *Filter) {
		var column string = "id ASC"
		f.idorderByAsc =&column
	}
}
func WithOrderByIDDesc()  FilterOpt {
	return func(f *Filter) {
		var column string = "id DESC"
		f.idorderByDesc =&column
	}
}
func WithName(name string)  FilterOpt {
	return func(f *Filter) {
		f.name = &name
	}
}
func WithNameNot(name string)  FilterOpt {
	return func(f *Filter) {
		f.notname = &name
	}
}
func WithNameMoreThen(name string)  FilterOpt {
	return func(f *Filter) {
		f.gtname = &name
	}
}
func WithNameLowerThen(name string)  FilterOpt {
	return func(f *Filter) {
		f.ltname = &name
	}
}
func WithNameMoreOrEqualThen(name string)  FilterOpt {
	return func(f *Filter) {
		f.gteqname = &name
	}
}
func WithNameLowerOrEqualThen(name string)  FilterOpt {
	return func(f *Filter) {
		f.lteqname = &name
	}
}
func WithNames (names ...string)  FilterOpt {
	return func(f *Filter) {
		f.names = append(f.names, names...)
	}
}

func WithOrderByNameAsc()  FilterOpt {
	return func(f *Filter) {
		var column string = "name ASC"
		f.nameorderByAsc =&column
	}
}
func WithOrderByNameDesc()  FilterOpt {
	return func(f *Filter) {
		var column string = "name DESC"
		f.nameorderByDesc =&column
	}
}
func WithEmail(email *string)  FilterOpt {
	return func(f *Filter) {
		f.email = &email
	}
}
func WithEmailNot(email *string)  FilterOpt {
	return func(f *Filter) {
		f.notemail = &email
	}
}
func WithEmailMoreThen(email *string)  FilterOpt {
	return func(f *Filter) {
		f.gtemail = &email
	}
}
func WithEmailLowerThen(email *string)  FilterOpt {
	return func(f *Filter) {
		f.ltemail = &email
	}
}
func WithEmailMoreOrEqualThen(email *string)  FilterOpt {
	return func(f *Filter) {
		f.gteqemail = &email
	}
}
func WithEmailLowerOrEqualThen(email *string)  FilterOpt {
	return func(f *Filter) {
		f.lteqemail = &email
	}
}
func WithEmails (emails ...*string)  FilterOpt {
	return func(f *Filter) {
		f.emails = append(f.emails, emails...)
	}
}

func WithOrderByEmailAsc()  FilterOpt {
	return func(f *Filter) {
		var column string = "email ASC"
		f.emailorderByAsc =&column
	}
}
func WithOrderByEmailDesc()  FilterOpt {
	return func(f *Filter) {
		var column string = "email DESC"
		f.emailorderByDesc =&column
	}
}
func WithBalance(balance float64)  FilterOpt {
	return func(f *Filter) {
		f.balance = &balance
	}
}
func WithBalanceNot(balance float64)  FilterOpt {
	return func(f *Filter) {
		f.notbalance = &balance
	}
}
func WithBalanceMoreThen(balance float64)  FilterOpt {
	return func(f *Filter) {
		f.gtbalance = &balance
	}
}
func WithBalanceLowerThen(balance float64)  FilterOpt {
	return func(f *Filter) {
		f.ltbalance = &balance
	}
}
func WithBalanceMoreOrEqualThen(balance float64)  FilterOpt {
	return func(f *Filter) {
		f.gteqbalance = &balance
	}
}
func WithBalanceLowerOrEqualThen(balance float64)  FilterOpt {
	return func(f *Filter) {
		f.lteqbalance = &balance
	}
}
func WithBalances (balances ...float64)  FilterOpt {
	return func(f *Filter) {
		f.balances = append(f.balances, balances...)
	}
}

func WithOrderByBalanceAsc()  FilterOpt {
	return func(f *Filter) {
		var column string = "balance ASC"
		f.balanceorderByAsc =&column
	}
}
func WithOrderByBalanceDesc()  FilterOpt {
	return func(f *Filter) {
		var column string = "balance DESC"
		f.balanceorderByDesc =&column
	}
}

func ApplyWhere[B interface {
    Where(pred interface{}, args ...interface{}) B
	Limit(limit uint64) B
	Offset(limit uint64) B
	OrderBy(orderBys ...string) B
}](b B,f Filter) B {
	if f.id != nil {
      b = b.Where(sq.Eq{ColumnUserID: *f.id})
    }
	if f.notid != nil {
      b = b.Where(sq.NotEq{ColumnUserID: *f.notid})
    }
	if f.ltid != nil {
      b = b.Where(sq.Lt{ColumnUserID: *f.ltid})
    }
	if f.gtid != nil {
      b = b.Where(sq.Gt{ColumnUserID: *f.gtid})
    }
	if f.lteqid != nil {
      b = b.Where(sq.LtOrEq{ColumnUserID: *f.lteqid})
    }
	if f.gteqid != nil {
      b = b.Where(sq.GtOrEq{ColumnUserID: *f.gteqid})
    }
	if f.ids != nil {
      b = b.Where(sq.Eq{ColumnUserID: f.ids})
    }
	if f.idorderByAsc != nil {
		b =b.OrderBy(*f.idorderByAsc)
	}
	if f.idorderByDesc != nil {
		b =b.OrderBy(*f.idorderByDesc)
	}
	if f.name != nil {
      b = b.Where(sq.Eq{ColumnUserName: *f.name})
    }
	if f.notname != nil {
      b = b.Where(sq.NotEq{ColumnUserName: *f.notname})
    }
	if f.ltname != nil {
      b = b.Where(sq.Lt{ColumnUserName: *f.ltname})
    }
	if f.gtname != nil {
      b = b.Where(sq.Gt{ColumnUserName: *f.gtname})
    }
	if f.lteqname != nil {
      b = b.Where(sq.LtOrEq{ColumnUserName: *f.lteqname})
    }
	if f.gteqname != nil {
      b = b.Where(sq.GtOrEq{ColumnUserName: *f.gteqname})
    }
	if f.names != nil {
      b = b.Where(sq.Eq{ColumnUserName: f.names})
    }
	if f.nameorderByAsc != nil {
		b =b.OrderBy(*f.nameorderByAsc)
	}
	if f.nameorderByDesc != nil {
		b =b.OrderBy(*f.nameorderByDesc)
	}
	if f.email != nil {
      b = b.Where(sq.Eq{ColumnUserEmail: *f.email})
    }
	if f.notemail != nil {
      b = b.Where(sq.NotEq{ColumnUserEmail: *f.notemail})
    }
	if f.ltemail != nil {
      b = b.Where(sq.Lt{ColumnUserEmail: *f.ltemail})
    }
	if f.gtemail != nil {
      b = b.Where(sq.Gt{ColumnUserEmail: *f.gtemail})
    }
	if f.lteqemail != nil {
      b = b.Where(sq.LtOrEq{ColumnUserEmail: *f.lteqemail})
    }
	if f.gteqemail != nil {
      b = b.Where(sq.GtOrEq{ColumnUserEmail: *f.gteqemail})
    }
	if f.emails != nil {
      b = b.Where(sq.Eq{ColumnUserEmail: f.emails})
    }
	if f.emailorderByAsc != nil {
		b =b.OrderBy(*f.emailorderByAsc)
	}
	if f.emailorderByDesc != nil {
		b =b.OrderBy(*f.emailorderByDesc)
	}
	if f.balance != nil {
      b = b.Where(sq.Eq{ColumnUserBalance: *f.balance})
    }
	if f.notbalance != nil {
      b = b.Where(sq.NotEq{ColumnUserBalance: *f.notbalance})
    }
	if f.ltbalance != nil {
      b = b.Where(sq.Lt{ColumnUserBalance: *f.ltbalance})
    }
	if f.gtbalance != nil {
      b = b.Where(sq.Gt{ColumnUserBalance: *f.gtbalance})
    }
	if f.lteqbalance != nil {
      b = b.Where(sq.LtOrEq{ColumnUserBalance: *f.lteqbalance})
    }
	if f.gteqbalance != nil {
      b = b.Where(sq.GtOrEq{ColumnUserBalance: *f.gteqbalance})
    }
	if f.balances != nil {
      b = b.Where(sq.Eq{ColumnUserBalance: f.balances})
    }
	if f.balanceorderByAsc != nil {
		b =b.OrderBy(*f.balanceorderByAsc)
	}
	if f.balanceorderByDesc != nil {
		b =b.OrderBy(*f.balanceorderByDesc)
	}

	if f.limit != nil {
		b  = b.Limit(uint64(*f.limit))
	}
	if f.offset != nil {
		b  = b.Offset(uint64(*f.offset))
	}

  return b
}

type UpdateOpt func(u *Update)

// UserUpdate represents the User update struct.
type Update struct {
  id *uuid.UUID
  name *string
  email **string
  balance *float64
}

func NewUpdate(opts ...UpdateOpt) Update{
	u := &Update{}
	for _, opt := range opts {
		opt(u)
	}
	return *u
}
func WithUpdateID(id uuid.UUID)  UpdateOpt {
	return func(f *Update) {
		f.id = &id
	}
}
func WithUpdateName(name string)  UpdateOpt {
	return func(f *Update) {
		f.name = &name
	}
}
func WithUpdateEmail(email *string)  UpdateOpt {
	return func(f *Update) {
		f.email = &email
	}
}
func WithUpdateBalance(balance float64)  UpdateOpt {
	return func(f *Update) {
		f.balance = &balance
	}
}

func ApplySet[B interface {
    Set(column string, value interface{}) B
}] (b B, f Update) B {
	if f.id != nil {
      b = b.Set(ColumnUserID, *f.id)
    }
	if f.name != nil {
      b = b.Set(ColumnUserName, *f.name)
    }
	if f.email != nil {
      b = b.Set(ColumnUserEmail, *f.email)
    }
	if f.balance != nil {
      b = b.Set(ColumnUserBalance, *f.balance)
    }

  return b
}
