//Code generated by generator, DO NOT EDIT.
package repository

import (
	sq "github.com/Masterminds/squirrel"
	common "github.com/AugustineAurelius/eos/example/common"
    "github.com/google/uuid"
)


type CommandRepository struct{
	db common.Querier
}

type QueryRepository struct{
	db common.Querier
}

func NewCommand(db common.Querier) *CommandRepository {
	return &CommandRepository{
		db: db,
	}
}

func NewQuery(db common.Querier) *QueryRepository {
	return &QueryRepository{
		db: db,
	}
}

// UserFiler represents the User filter.
type Filter struct {
  id *uuid.UUID
  notid *uuid.UUID
  gtid *uuid.UUID
  ltid *uuid.UUID
  gteqid *uuid.UUID
  lteqid *uuid.UUID
  ids []uuid.UUID
  name *string
  notname *string
  gtname *string
  ltname *string
  gteqname *string
  lteqname *string
  names []string
  email **string
  notemail **string
  gtemail **string
  ltemail **string
  gteqemail **string
  lteqemail **string
  emails []*string
  booler *bool
  notbooler *bool
  gtbooler *bool
  ltbooler *bool
  gteqbooler *bool
  lteqbooler *bool
  boolers []bool
  balance *float64
  notbalance *float64
  gtbalance *float64
  ltbalance *float64
  gteqbalance *float64
  lteqbalance *float64
  balances []float64
}

type FilterOpt func(f *Filter)

func NewFilter(opts ...FilterOpt) Filter{
	f := &Filter{}
	for _, opt := range opts {
		opt(f)
	}
	return *f
}
func WithID(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.id = &id
	}
}
func WithIDNot(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.notid = &id
	}
}
func WithIDMoreThen(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.gtid = &id
	}
}
func WithIDLowerThen(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.ltid = &id
	}
}
func WithIDMoreOrEqualThen(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.gteqid = &id
	}
}
func WithIDLowerOrEqualThen(id uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.lteqid = &id
	}
}
func WithIDs (ids ...uuid.UUID)  FilterOpt {
	return func(f *Filter) {
		f.ids = append(f.ids, ids...)
	}
}
func WithName(name string)  FilterOpt {
	return func(f *Filter) {
		f.name = &name
	}
}
func WithNameNot(name string)  FilterOpt {
	return func(f *Filter) {
		f.notname = &name
	}
}
func WithNameMoreThen(name string)  FilterOpt {
	return func(f *Filter) {
		f.gtname = &name
	}
}
func WithNameLowerThen(name string)  FilterOpt {
	return func(f *Filter) {
		f.ltname = &name
	}
}
func WithNameMoreOrEqualThen(name string)  FilterOpt {
	return func(f *Filter) {
		f.gteqname = &name
	}
}
func WithNameLowerOrEqualThen(name string)  FilterOpt {
	return func(f *Filter) {
		f.lteqname = &name
	}
}
func WithNames (names ...string)  FilterOpt {
	return func(f *Filter) {
		f.names = append(f.names, names...)
	}
}
func WithEmail(email *string)  FilterOpt {
	return func(f *Filter) {
		f.email = &email
	}
}
func WithEmailNot(email *string)  FilterOpt {
	return func(f *Filter) {
		f.notemail = &email
	}
}
func WithEmailMoreThen(email *string)  FilterOpt {
	return func(f *Filter) {
		f.gtemail = &email
	}
}
func WithEmailLowerThen(email *string)  FilterOpt {
	return func(f *Filter) {
		f.ltemail = &email
	}
}
func WithEmailMoreOrEqualThen(email *string)  FilterOpt {
	return func(f *Filter) {
		f.gteqemail = &email
	}
}
func WithEmailLowerOrEqualThen(email *string)  FilterOpt {
	return func(f *Filter) {
		f.lteqemail = &email
	}
}
func WithEmails (emails ...*string)  FilterOpt {
	return func(f *Filter) {
		f.emails = append(f.emails, emails...)
	}
}
func WithBooler(booler bool)  FilterOpt {
	return func(f *Filter) {
		f.booler = &booler
	}
}
func WithBoolerNot(booler bool)  FilterOpt {
	return func(f *Filter) {
		f.notbooler = &booler
	}
}
func WithBoolerMoreThen(booler bool)  FilterOpt {
	return func(f *Filter) {
		f.gtbooler = &booler
	}
}
func WithBoolerLowerThen(booler bool)  FilterOpt {
	return func(f *Filter) {
		f.ltbooler = &booler
	}
}
func WithBoolerMoreOrEqualThen(booler bool)  FilterOpt {
	return func(f *Filter) {
		f.gteqbooler = &booler
	}
}
func WithBoolerLowerOrEqualThen(booler bool)  FilterOpt {
	return func(f *Filter) {
		f.lteqbooler = &booler
	}
}
func WithBoolers (boolers ...bool)  FilterOpt {
	return func(f *Filter) {
		f.boolers = append(f.boolers, boolers...)
	}
}
func WithBalance(balance float64)  FilterOpt {
	return func(f *Filter) {
		f.balance = &balance
	}
}
func WithBalanceNot(balance float64)  FilterOpt {
	return func(f *Filter) {
		f.notbalance = &balance
	}
}
func WithBalanceMoreThen(balance float64)  FilterOpt {
	return func(f *Filter) {
		f.gtbalance = &balance
	}
}
func WithBalanceLowerThen(balance float64)  FilterOpt {
	return func(f *Filter) {
		f.ltbalance = &balance
	}
}
func WithBalanceMoreOrEqualThen(balance float64)  FilterOpt {
	return func(f *Filter) {
		f.gteqbalance = &balance
	}
}
func WithBalanceLowerOrEqualThen(balance float64)  FilterOpt {
	return func(f *Filter) {
		f.lteqbalance = &balance
	}
}
func WithBalances (balances ...float64)  FilterOpt {
	return func(f *Filter) {
		f.balances = append(f.balances, balances...)
	}
}

func ApplyWhere[B interface {
    Where(pred interface{}, args ...interface{}) B
}](b B,f Filter) B {
	if f.id != nil {
      b = b.Where(sq.Eq{ColumnUserID: *f.id})
    }
	if f.notid != nil {
      b = b.Where(sq.NotEq{ColumnUserID: *f.notid})
    }
	if f.ltid != nil {
      b = b.Where(sq.Lt{ColumnUserID: *f.ltid})
    }
	if f.gtid != nil {
      b = b.Where(sq.Gt{ColumnUserID: *f.gtid})
    }
	if f.lteqid != nil {
      b = b.Where(sq.LtOrEq{ColumnUserID: *f.lteqid})
    }
	if f.gteqid != nil {
      b = b.Where(sq.GtOrEq{ColumnUserID: *f.gteqid})
    }
	if f.ids != nil {
      b = b.Where(sq.Eq{ColumnUserID: f.ids})
    }
	if f.name != nil {
      b = b.Where(sq.Eq{ColumnUserName: *f.name})
    }
	if f.notname != nil {
      b = b.Where(sq.NotEq{ColumnUserName: *f.notname})
    }
	if f.ltname != nil {
      b = b.Where(sq.Lt{ColumnUserName: *f.ltname})
    }
	if f.gtname != nil {
      b = b.Where(sq.Gt{ColumnUserName: *f.gtname})
    }
	if f.lteqname != nil {
      b = b.Where(sq.LtOrEq{ColumnUserName: *f.lteqname})
    }
	if f.gteqname != nil {
      b = b.Where(sq.GtOrEq{ColumnUserName: *f.gteqname})
    }
	if f.names != nil {
      b = b.Where(sq.Eq{ColumnUserName: f.names})
    }
	if f.email != nil {
      b = b.Where(sq.Eq{ColumnUserEmail: *f.email})
    }
	if f.notemail != nil {
      b = b.Where(sq.NotEq{ColumnUserEmail: *f.notemail})
    }
	if f.ltemail != nil {
      b = b.Where(sq.Lt{ColumnUserEmail: *f.ltemail})
    }
	if f.gtemail != nil {
      b = b.Where(sq.Gt{ColumnUserEmail: *f.gtemail})
    }
	if f.lteqemail != nil {
      b = b.Where(sq.LtOrEq{ColumnUserEmail: *f.lteqemail})
    }
	if f.gteqemail != nil {
      b = b.Where(sq.GtOrEq{ColumnUserEmail: *f.gteqemail})
    }
	if f.emails != nil {
      b = b.Where(sq.Eq{ColumnUserEmail: f.emails})
    }
	if f.booler != nil {
      b = b.Where(sq.Eq{ColumnUserBooler: *f.booler})
    }
	if f.notbooler != nil {
      b = b.Where(sq.NotEq{ColumnUserBooler: *f.notbooler})
    }
	if f.ltbooler != nil {
      b = b.Where(sq.Lt{ColumnUserBooler: *f.ltbooler})
    }
	if f.gtbooler != nil {
      b = b.Where(sq.Gt{ColumnUserBooler: *f.gtbooler})
    }
	if f.lteqbooler != nil {
      b = b.Where(sq.LtOrEq{ColumnUserBooler: *f.lteqbooler})
    }
	if f.gteqbooler != nil {
      b = b.Where(sq.GtOrEq{ColumnUserBooler: *f.gteqbooler})
    }
	if f.boolers != nil {
      b = b.Where(sq.Eq{ColumnUserBooler: f.boolers})
    }
	if f.balance != nil {
      b = b.Where(sq.Eq{ColumnUserBalance: *f.balance})
    }
	if f.notbalance != nil {
      b = b.Where(sq.NotEq{ColumnUserBalance: *f.notbalance})
    }
	if f.ltbalance != nil {
      b = b.Where(sq.Lt{ColumnUserBalance: *f.ltbalance})
    }
	if f.gtbalance != nil {
      b = b.Where(sq.Gt{ColumnUserBalance: *f.gtbalance})
    }
	if f.lteqbalance != nil {
      b = b.Where(sq.LtOrEq{ColumnUserBalance: *f.lteqbalance})
    }
	if f.gteqbalance != nil {
      b = b.Where(sq.GtOrEq{ColumnUserBalance: *f.gteqbalance})
    }
	if f.balances != nil {
      b = b.Where(sq.Eq{ColumnUserBalance: f.balances})
    }
  return b
}

type UpdateOpt func(u *Update)

// UserUpdate represents the User update struct.
type Update struct {
  id *uuid.UUID
  name *string
  email **string
  booler *bool
  balance *float64
}

func NewUpdate(opts ...UpdateOpt) Update{
	u := &Update{}
	for _, opt := range opts {
		opt(u)
	}
	return *u
}
func WithUpdateID(id uuid.UUID)  UpdateOpt {
	return func(f *Update) {
		f.id = &id
	}
}
func WithUpdateName(name string)  UpdateOpt {
	return func(f *Update) {
		f.name = &name
	}
}
func WithUpdateEmail(email *string)  UpdateOpt {
	return func(f *Update) {
		f.email = &email
	}
}
func WithUpdateBooler(booler bool)  UpdateOpt {
	return func(f *Update) {
		f.booler = &booler
	}
}
func WithUpdateBalance(balance float64)  UpdateOpt {
	return func(f *Update) {
		f.balance = &balance
	}
}

func ApplySet[B interface {
    Set(column string, value interface{}) B
}] (b B, f Update) B {
	if f.id != nil {
      b = b.Set(ColumnUserID, *f.id)
    }
	if f.name != nil {
      b = b.Set(ColumnUserName, *f.name)
    }
	if f.email != nil {
      b = b.Set(ColumnUserEmail, *f.email)
    }
	if f.booler != nil {
      b = b.Set(ColumnUserBooler, *f.booler)
    }
	if f.balance != nil {
      b = b.Set(ColumnUserBalance, *f.balance)
    }

  return b
}
