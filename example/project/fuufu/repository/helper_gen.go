// Code generated by generator, DO NOT EDIT.
package repository

import (
	"iter"
	"reflect"
	"slices"
	"sort"
	"time"

	"github.com/google/uuid"
)

type Tasks []Task

func (s Tasks) ToIDs() []uuid.UUID {
	output := make([]uuid.UUID, 0, len(s))
	for i := 0; i < len(s); i++ {
		output = append(output, s[i].ID)
	}
	return output
}
func (s Tasks) ToNames() []string {
	output := make([]string, 0, len(s))
	for i := 0; i < len(s); i++ {
		output = append(output, s[i].Name)
	}
	return output
}
func (s Tasks) ToDescriptions() []*string {
	output := make([]*string, 0, len(s))
	for i := 0; i < len(s); i++ {
		output = append(output, s[i].Description)
	}
	return output
}
func (s Tasks) ToCreatedBys() []string {
	output := make([]string, 0, len(s))
	for i := 0; i < len(s); i++ {
		output = append(output, s[i].CreatedBy)
	}
	return output
}
func (s Tasks) ToDoers() []string {
	output := make([]string, 0, len(s))
	for i := 0; i < len(s); i++ {
		output = append(output, s[i].Doer)
	}
	return output
}
func (s Tasks) ToDones() []bool {
	output := make([]bool, 0, len(s))
	for i := 0; i < len(s); i++ {
		output = append(output, s[i].Done)
	}
	return output
}
func (s Tasks) ToRepeatables() []bool {
	output := make([]bool, 0, len(s))
	for i := 0; i < len(s); i++ {
		output = append(output, s[i].Repeatable)
	}
	return output
}
func (s Tasks) ToRepeatAfters() []*int {
	output := make([]*int, 0, len(s))
	for i := 0; i < len(s); i++ {
		output = append(output, s[i].RepeatAfter)
	}
	return output
}
func (s Tasks) ToDoBefores() []*time.Time {
	output := make([]*time.Time, 0, len(s))
	for i := 0; i < len(s); i++ {
		output = append(output, s[i].DoBefore)
	}
	return output
}
func (s Tasks) ToCreatedAts() []time.Time {
	output := make([]time.Time, 0, len(s))
	for i := 0; i < len(s); i++ {
		output = append(output, s[i].CreatedAt)
	}
	return output
}
func (s Tasks) ToUpdatedAts() []*time.Time {
	output := make([]*time.Time, 0, len(s))
	for i := 0; i < len(s); i++ {
		output = append(output, s[i].UpdatedAt)
	}
	return output
}
func (s Tasks) FindByID(finder uuid.UUID) (Task, bool) {
	for i := 0; i < len(s); i++ {
		if s[i].ID == finder {
			return s[i], true
		}
	}
	return Task{}, false
}
func (s Tasks) FindByName(finder string) (Task, bool) {
	for i := 0; i < len(s); i++ {
		if s[i].Name == finder {
			return s[i], true
		}
	}
	return Task{}, false
}
func (s Tasks) FindByDescription(finder *string) (Task, bool) {
	for i := 0; i < len(s); i++ {
		if s[i].Description == finder {
			return s[i], true
		}
	}
	return Task{}, false
}
func (s Tasks) FindByCreatedBy(finder string) (Task, bool) {
	for i := 0; i < len(s); i++ {
		if s[i].CreatedBy == finder {
			return s[i], true
		}
	}
	return Task{}, false
}
func (s Tasks) FindByDoer(finder string) (Task, bool) {
	for i := 0; i < len(s); i++ {
		if s[i].Doer == finder {
			return s[i], true
		}
	}
	return Task{}, false
}
func (s Tasks) FindByDone(finder bool) (Task, bool) {
	for i := 0; i < len(s); i++ {
		if s[i].Done == finder {
			return s[i], true
		}
	}
	return Task{}, false
}
func (s Tasks) FindByRepeatable(finder bool) (Task, bool) {
	for i := 0; i < len(s); i++ {
		if s[i].Repeatable == finder {
			return s[i], true
		}
	}
	return Task{}, false
}
func (s Tasks) FindByRepeatAfter(finder *int) (Task, bool) {
	for i := 0; i < len(s); i++ {
		if s[i].RepeatAfter == finder {
			return s[i], true
		}
	}
	return Task{}, false
}
func (s Tasks) FindByDoBefore(finder *time.Time) (Task, bool) {
	for i := 0; i < len(s); i++ {
		if s[i].DoBefore == finder {
			return s[i], true
		}
	}
	return Task{}, false
}
func (s Tasks) FindByCreatedAt(finder time.Time) (Task, bool) {
	for i := 0; i < len(s); i++ {
		if s[i].CreatedAt == finder {
			return s[i], true
		}
	}
	return Task{}, false
}
func (s Tasks) FindByUpdatedAt(finder *time.Time) (Task, bool) {
	for i := 0; i < len(s); i++ {
		if s[i].UpdatedAt == finder {
			return s[i], true
		}
	}
	return Task{}, false
}
func (s Tasks) SortByName(asc bool) Tasks {
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return s[i].Name < s[j].Name
		})
		return s
	}
	sort.Slice(s, func(i, j int) bool {
		return s[i].Name > s[j].Name
	})
	return s
}
func (s Tasks) SortByDescription(asc bool) Tasks {
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return *s[i].Description < *s[j].Description
		})
		return s
	}
	sort.Slice(s, func(i, j int) bool {
		return *s[i].Description > *s[j].Description
	})
	return s
}
func (s Tasks) SortByCreatedBy(asc bool) Tasks {
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return s[i].CreatedBy < s[j].CreatedBy
		})
		return s
	}
	sort.Slice(s, func(i, j int) bool {
		return s[i].CreatedBy > s[j].CreatedBy
	})
	return s
}
func (s Tasks) SortByDoer(asc bool) Tasks {
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return s[i].Doer < s[j].Doer
		})
		return s
	}
	sort.Slice(s, func(i, j int) bool {
		return s[i].Doer > s[j].Doer
	})
	return s
}
func (s Tasks) SortByRepeatAfter(asc bool) Tasks {
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return *s[i].RepeatAfter < *s[j].RepeatAfter
		})
		return s
	}
	sort.Slice(s, func(i, j int) bool {
		return *s[i].RepeatAfter > *s[j].RepeatAfter
	})
	return s
}
func (s Tasks) SortByDoBefore(asc bool) Tasks {
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return s[i].DoBefore.Before(*s[j].DoBefore)
		})
		return s
	}
	sort.Slice(s, func(i, j int) bool {
		return s[i].DoBefore.After(*s[j].DoBefore)
	})
	return s
}
func (s Tasks) SortByCreatedAt(asc bool) Tasks {
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return s[i].CreatedAt.Before(s[j].CreatedAt)
		})
		return s
	}
	sort.Slice(s, func(i, j int) bool {
		return s[i].CreatedAt.After(s[j].CreatedAt)
	})
	return s
}
func (s Tasks) SortByUpdatedAt(asc bool) Tasks {
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return s[i].UpdatedAt.Before(*s[j].UpdatedAt)
		})
		return s
	}
	sort.Slice(s, func(i, j int) bool {
		return s[i].UpdatedAt.After(*s[j].UpdatedAt)
	})
	return s
}

func (s Tasks) FilterFunc(f func(i Task) bool) Tasks {
	output := make(Tasks, 0, len(s))
	for i := 0; i < len(s); i++ {
		if f(s[i]) {
			output = append(output, s[i])
		}
	}
	return output
}
func (s Tasks) GetFirstID() (*uuid.UUID, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].ID, true
}
func (s Tasks) GetFirstName() (*string, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].Name, true
}
func (s Tasks) GetFirstDescription() (**string, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].Description, true
}
func (s Tasks) GetFirstCreatedBy() (*string, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].CreatedBy, true
}
func (s Tasks) GetFirstDoer() (*string, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].Doer, true
}
func (s Tasks) GetFirstDone() (*bool, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].Done, true
}
func (s Tasks) GetFirstRepeatable() (*bool, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].Repeatable, true
}
func (s Tasks) GetFirstRepeatAfter() (**int, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].RepeatAfter, true
}
func (s Tasks) GetFirstDoBefore() (**time.Time, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].DoBefore, true
}
func (s Tasks) GetFirstCreatedAt() (*time.Time, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].CreatedAt, true
}
func (s Tasks) GetFirstUpdatedAt() (**time.Time, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].UpdatedAt, true
}

func (s Tasks) GetFirst() (Task, bool) {
	if len(s) < 1 {
		return Task{}, false
	}
	return s[0], true
}

func (s Tasks) All() iterTask {
	return func(yield func(Task) bool) {
		for _, elem := range s {
			if !yield(elem) {
				return
			}
		}
	}
}

// Iterators
type iterTask iter.Seq[Task]

func (i iterTask) FilterFunc(predicate func(Task) bool) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if predicate(elem) && !yield(elem) {
				return
			}
		}
	}
}

func (i iterTask) Map(transform func(Task) Task) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if !yield(transform(elem)) {
				return
			}
		}
	}
}

func (i iterTask) Take(n int) iterTask {
	count := 0
	return func(yield func(Task) bool) {
		for elem := range i {
			if count >= n || !yield(elem) {
				return
			}
			count++
		}
	}
}

func (i iterTask) Find(findFunc func(Task) bool) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if findFunc(elem) && !yield(elem) {
				return
			}
		}
	}
}

// doesnot work with pointers
func (i iterTask) Distinct(keyFunc func(Task) any) iterTask {
	seen := make(map[any]bool)
	return func(yield func(Task) bool) {
		for elem := range i {
			key := keyFunc(elem)
			if key != nil {
				val := reflect.ValueOf(key)
				switch val.Kind() {
				case reflect.Ptr, reflect.Interface,
					reflect.Slice, reflect.Map,
					reflect.Chan, reflect.Func:
					if val.IsNil() {
						continue
					}
				}
			}
			if !seen[key] {
				seen[key] = true
				if !yield(elem) {
					return
				}
			}
		}
	}
}
func (i iterTask) FilterByID(id uuid.UUID) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if id == elem.ID && !yield(elem) {
				return
			}
		}
	}
}
func (i iterTask) FilterByName(name string) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if name == elem.Name && !yield(elem) {
				return
			}
		}
	}
}
func (i iterTask) FilterByDescription(description *string) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if description == elem.Description && !yield(elem) {
				return
			}
		}
	}
}
func (i iterTask) FilterByCreatedBy(createdby string) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if createdby == elem.CreatedBy && !yield(elem) {
				return
			}
		}
	}
}
func (i iterTask) FilterByDoer(doer string) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if doer == elem.Doer && !yield(elem) {
				return
			}
		}
	}
}
func (i iterTask) FilterByDone(done bool) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if done == elem.Done && !yield(elem) {
				return
			}
		}
	}
}
func (i iterTask) FilterByRepeatable(repeatable bool) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if repeatable == elem.Repeatable && !yield(elem) {
				return
			}
		}
	}
}
func (i iterTask) FilterByRepeatAfter(repeatafter *int) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if repeatafter == elem.RepeatAfter && !yield(elem) {
				return
			}
		}
	}
}
func (i iterTask) FilterByDoBefore(dobefore *time.Time) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if dobefore == elem.DoBefore && !yield(elem) {
				return
			}
		}
	}
}
func (i iterTask) FilterByCreatedAt(createdat time.Time) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if createdat == elem.CreatedAt && !yield(elem) {
				return
			}
		}
	}
}
func (i iterTask) FilterByUpdatedAt(updatedat *time.Time) iterTask {
	return func(yield func(Task) bool) {
		for elem := range i {
			if updatedat == elem.UpdatedAt && !yield(elem) {
				return
			}
		}
	}
}
func (i iterTask) ToNames() iter.Seq[string] {
	return func(yield func(string) bool) {
		for elem := range i {
			if !yield(elem.Name) {
				return
			}
		}
	}
}
func (i iterTask) ToDescriptions() iter.Seq[*string] {
	return func(yield func(*string) bool) {
		for elem := range i {
			if !yield(elem.Description) {
				return
			}
		}
	}
}
func (i iterTask) ToCreatedBys() iter.Seq[string] {
	return func(yield func(string) bool) {
		for elem := range i {
			if !yield(elem.CreatedBy) {
				return
			}
		}
	}
}
func (i iterTask) ToDoers() iter.Seq[string] {
	return func(yield func(string) bool) {
		for elem := range i {
			if !yield(elem.Doer) {
				return
			}
		}
	}
}
func (i iterTask) ToDones() iter.Seq[bool] {
	return func(yield func(bool) bool) {
		for elem := range i {
			if !yield(elem.Done) {
				return
			}
		}
	}
}
func (i iterTask) ToRepeatables() iter.Seq[bool] {
	return func(yield func(bool) bool) {
		for elem := range i {
			if !yield(elem.Repeatable) {
				return
			}
		}
	}
}


func (i iterTask) First() (Task, bool) {
	for elem := range i {
		return elem, true
	}
	return Task{}, false
}

func (i iterTask) ForEach(f func(Task)) {
	for elem := range i {
		f(elem)
	}
}

func (i iterTask) Collect() []Task {
	return slices.Collect(iter.Seq[Task](i))
}

// -1 if x is less than y,
//
//	0 if x equals y,
//
// +1 if x is greater than y.
func (i iterTask) Sort(sortFunc func(x, y Task) int) []Task {
	return slices.SortedFunc(iter.Seq[Task](i), sortFunc)
}

type intIter iter.Seq[int]
type int8Iter iter.Seq[int8]
type int16Iter iter.Seq[int16]
type int32Iter iter.Seq[int32]
type int64Iter iter.Seq[int64]
type uintIter iter.Seq[uint]
type uint8Iter iter.Seq[uint8]
type uint16Iter iter.Seq[uint16]
type uint32Iter iter.Seq[uint32]
type uint64Iter iter.Seq[uint64]
type uintptrIter iter.Seq[uintptr]
type float32Iter iter.Seq[float32]
type float64Iter iter.Seq[float64]

func (i intIter) Sum() int {
	var res int
	for elem := range i {
		res += elem
	}
	return res
}
func (i intIter) Min() int {
	var min int
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i intIter) Max() int {
	var max int
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i intIter) Average() int {
	var sum, count int
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
func (i int8Iter) Sum() int8 {
	var res int8
	for elem := range i {
		res += elem
	}
	return res
}
func (i int8Iter) Min() int8 {
	var min int8
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i int8Iter) Max() int8 {
	var max int8
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i int8Iter) Average() int8 {
	var sum, count int8
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
func (i int16Iter) Sum() int16 {
	var res int16
	for elem := range i {
		res += elem
	}
	return res
}
func (i int16Iter) Min() int16 {
	var min int16
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i int16Iter) Max() int16 {
	var max int16
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i int16Iter) Average() int16 {
	var sum, count int16
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
func (i int32Iter) Sum() int32 {
	var res int32
	for elem := range i {
		res += elem
	}
	return res
}
func (i int32Iter) Min() int32 {
	var min int32
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i int32Iter) Max() int32 {
	var max int32
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i int32Iter) Average() int32 {
	var sum, count int32
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
func (i int64Iter) Sum() int64 {
	var res int64
	for elem := range i {
		res += elem
	}
	return res
}
func (i int64Iter) Min() int64 {
	var min int64
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i int64Iter) Max() int64 {
	var max int64
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i int64Iter) Average() int64 {
	var sum, count int64
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
func (i uintIter) Sum() uint {
	var res uint
	for elem := range i {
		res += elem
	}
	return res
}
func (i uintIter) Min() uint {
	var min uint
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i uintIter) Max() uint {
	var max uint
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i uintIter) Average() uint {
	var sum, count uint
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
func (i uint8Iter) Sum() uint8 {
	var res uint8
	for elem := range i {
		res += elem
	}
	return res
}
func (i uint8Iter) Min() uint8 {
	var min uint8
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i uint8Iter) Max() uint8 {
	var max uint8
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i uint8Iter) Average() uint8 {
	var sum, count uint8
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
func (i uint16Iter) Sum() uint16 {
	var res uint16
	for elem := range i {
		res += elem
	}
	return res
}
func (i uint16Iter) Min() uint16 {
	var min uint16
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i uint16Iter) Max() uint16 {
	var max uint16
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i uint16Iter) Average() uint16 {
	var sum, count uint16
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
func (i uint32Iter) Sum() uint32 {
	var res uint32
	for elem := range i {
		res += elem
	}
	return res
}
func (i uint32Iter) Min() uint32 {
	var min uint32
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i uint32Iter) Max() uint32 {
	var max uint32
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i uint32Iter) Average() uint32 {
	var sum, count uint32
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
func (i uint64Iter) Sum() uint64 {
	var res uint64
	for elem := range i {
		res += elem
	}
	return res
}
func (i uint64Iter) Min() uint64 {
	var min uint64
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i uint64Iter) Max() uint64 {
	var max uint64
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i uint64Iter) Average() uint64 {
	var sum, count uint64
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
func (i uintptrIter) Sum() uintptr {
	var res uintptr
	for elem := range i {
		res += elem
	}
	return res
}
func (i uintptrIter) Min() uintptr {
	var min uintptr
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i uintptrIter) Max() uintptr {
	var max uintptr
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i uintptrIter) Average() uintptr {
	var sum, count uintptr
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
func (i float32Iter) Sum() float32 {
	var res float32
	for elem := range i {
		res += elem
	}
	return res
}
func (i float32Iter) Min() float32 {
	var min float32
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i float32Iter) Max() float32 {
	var max float32
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i float32Iter) Average() float32 {
	var sum, count float32
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
func (i float64Iter) Sum() float64 {
	var res float64
	for elem := range i {
		res += elem
	}
	return res
}
func (i float64Iter) Min() float64 {
	var min float64
	first := true
	for elem := range i {
		if first || elem < min {
			min = elem
			first = false
		}
	}
	return min
}
func (i float64Iter) Max() float64 {
	var max float64
	first := true
	for elem := range i {
		if first || elem > max {
			max = elem
			first = false
		}
	}
	return max
}
func (i float64Iter) Average() float64 {
	var sum, count float64
	for elem := range i {
		sum += elem
		count++
	}
	if count == 0 {
		return 0
	}
	return sum / count
}
