// Code generated by generator, DO NOT EDIT.
package repository

import (
	"context"
	"fmt"

	"time"

	common "github.com/AugustineAurelius/fuufu/pkg/common"
	sq "github.com/Masterminds/squirrel"
	"github.com/google/uuid"
)

// GetTask retrieves a Task by ID.
func (r *CommandRepository) Get(ctx context.Context, opts ...FilterOpt) (*Task, error) {
	return get(ctx, r.db, opts...)
}

func (r *QueryRepository) Get(ctx context.Context, opts ...FilterOpt) (*Task, error) {
	return get(ctx, r.db, opts...)
}

// GetManyTask retrieves a Task by filter.
func (r *CommandRepository) GetMany(ctx context.Context, opts ...FilterOpt) (Tasks, error) {
	return getMany(ctx, r.db, opts...)
}

// GetManyTask retrieves a Task by filter.
func (r *QueryRepository) GetMany(ctx context.Context, opts ...FilterOpt) (Tasks, error) {
	return getMany(ctx, r.db, opts...)
}

func get(ctx context.Context, run common.Querier, opts ...FilterOpt) (*Task, error) {
	b := sq.Select(
		ColumnTaskID,
		ColumnTaskName,
		ColumnTaskDescription,
		ColumnTaskCreatedBy,
		ColumnTaskDoer,
		ColumnTaskDone,
		ColumnTaskRepeatable,
		ColumnTaskRepeatAfter,
		ColumnTaskDoBefore,
		ColumnTaskCreatedAt,
		ColumnTaskUpdatedAt,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)

	query, args := b.MustSql()

	var taskModel TaskModel
	err := run.QueryRow(ctx, query, args...).Scan(
		&taskModel.ID,
		&taskModel.Name,
		&taskModel.Description,
		&taskModel.CreatedBy,
		&taskModel.Doer,
		&taskModel.Done,
		&taskModel.Repeatable,
		&taskModel.RepeatAfter,
		&taskModel.DoBefore,
		&taskModel.CreatedAt,
		&taskModel.UpdatedAt,
	)
	if err != nil {
		return nil, fmt.Errorf("failed to get query %s with args %v error = %w", query, args, err)
	}

	task := ReverseConverter(taskModel)

	return &task, err
}

func getMany(ctx context.Context, run common.Querier, opts ...FilterOpt) (Tasks, error) {
	b := sq.Select(
		ColumnTaskID,
		ColumnTaskName,
		ColumnTaskDescription,
		ColumnTaskCreatedBy,
		ColumnTaskDoer,
		ColumnTaskDone,
		ColumnTaskRepeatable,
		ColumnTaskRepeatAfter,
		ColumnTaskDoBefore,
		ColumnTaskCreatedAt,
		ColumnTaskUpdatedAt,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)

	query, args := b.MustSql()

	var tasks Tasks

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var taskModel TaskModel
	for rows.Next() {
		err := rows.Scan(
			&taskModel.ID,
			&taskModel.Name,
			&taskModel.Description,
			&taskModel.CreatedBy,
			&taskModel.Doer,
			&taskModel.Done,
			&taskModel.Repeatable,
			&taskModel.RepeatAfter,
			&taskModel.DoBefore,
			&taskModel.CreatedAt,
			&taskModel.UpdatedAt,
		)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		tasks = append(tasks, ReverseConverter(taskModel))
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return tasks, err
}
func (r *CommandRepository) GetID(ctx context.Context, opts ...FilterOpt) ([]uuid.UUID, error) {
	return getID(ctx, r.db, opts...)
}

func (r *QueryRepository) GetID(ctx context.Context, opts ...FilterOpt) ([]uuid.UUID, error) {
	return getID(ctx, r.db, opts...)
}

func getID(ctx context.Context, run common.Querier, opts ...FilterOpt) ([]uuid.UUID, error) {
	b := sq.Select(
		ColumnTaskID,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)
	query, args := b.MustSql()
	IDs := make([]uuid.UUID, 0, 32)

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var temp uuid.UUID
	for rows.Next() {
		err = rows.Scan(&temp)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		IDs = append(IDs, temp)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return IDs, err
}
func (r *CommandRepository) GetName(ctx context.Context, opts ...FilterOpt) ([]string, error) {
	return getName(ctx, r.db, opts...)
}

func (r *QueryRepository) GetName(ctx context.Context, opts ...FilterOpt) ([]string, error) {
	return getName(ctx, r.db, opts...)
}

func getName(ctx context.Context, run common.Querier, opts ...FilterOpt) ([]string, error) {
	b := sq.Select(
		ColumnTaskName,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)
	query, args := b.MustSql()
	Names := make([]string, 0, 32)

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var temp string
	for rows.Next() {
		err = rows.Scan(&temp)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		Names = append(Names, temp)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return Names, err
}
func (r *CommandRepository) GetDescription(ctx context.Context, opts ...FilterOpt) ([]*string, error) {
	return getDescription(ctx, r.db, opts...)
}

func (r *QueryRepository) GetDescription(ctx context.Context, opts ...FilterOpt) ([]*string, error) {
	return getDescription(ctx, r.db, opts...)
}

func getDescription(ctx context.Context, run common.Querier, opts ...FilterOpt) ([]*string, error) {
	b := sq.Select(
		ColumnTaskDescription,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)
	query, args := b.MustSql()
	Descriptions := make([]*string, 0, 32)

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var temp *string
	for rows.Next() {
		err = rows.Scan(&temp)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		Descriptions = append(Descriptions, temp)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return Descriptions, err
}
func (r *CommandRepository) GetCreatedBy(ctx context.Context, opts ...FilterOpt) ([]string, error) {
	return getCreatedBy(ctx, r.db, opts...)
}

func (r *QueryRepository) GetCreatedBy(ctx context.Context, opts ...FilterOpt) ([]string, error) {
	return getCreatedBy(ctx, r.db, opts...)
}

func getCreatedBy(ctx context.Context, run common.Querier, opts ...FilterOpt) ([]string, error) {
	b := sq.Select(
		ColumnTaskCreatedBy,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)
	query, args := b.MustSql()
	CreatedBys := make([]string, 0, 32)

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var temp string
	for rows.Next() {
		err = rows.Scan(&temp)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		CreatedBys = append(CreatedBys, temp)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return CreatedBys, err
}
func (r *CommandRepository) GetDoer(ctx context.Context, opts ...FilterOpt) ([]string, error) {
	return getDoer(ctx, r.db, opts...)
}

func (r *QueryRepository) GetDoer(ctx context.Context, opts ...FilterOpt) ([]string, error) {
	return getDoer(ctx, r.db, opts...)
}

func getDoer(ctx context.Context, run common.Querier, opts ...FilterOpt) ([]string, error) {
	b := sq.Select(
		ColumnTaskDoer,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)
	query, args := b.MustSql()
	Doers := make([]string, 0, 32)

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var temp string
	for rows.Next() {
		err = rows.Scan(&temp)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		Doers = append(Doers, temp)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return Doers, err
}
func (r *CommandRepository) GetDone(ctx context.Context, opts ...FilterOpt) ([]bool, error) {
	return getDone(ctx, r.db, opts...)
}

func (r *QueryRepository) GetDone(ctx context.Context, opts ...FilterOpt) ([]bool, error) {
	return getDone(ctx, r.db, opts...)
}

func getDone(ctx context.Context, run common.Querier, opts ...FilterOpt) ([]bool, error) {
	b := sq.Select(
		ColumnTaskDone,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)
	query, args := b.MustSql()
	Dones := make([]bool, 0, 32)

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var temp bool
	for rows.Next() {
		err = rows.Scan(&temp)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		Dones = append(Dones, temp)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return Dones, err
}
func (r *CommandRepository) GetRepeatable(ctx context.Context, opts ...FilterOpt) ([]bool, error) {
	return getRepeatable(ctx, r.db, opts...)
}

func (r *QueryRepository) GetRepeatable(ctx context.Context, opts ...FilterOpt) ([]bool, error) {
	return getRepeatable(ctx, r.db, opts...)
}

func getRepeatable(ctx context.Context, run common.Querier, opts ...FilterOpt) ([]bool, error) {
	b := sq.Select(
		ColumnTaskRepeatable,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)
	query, args := b.MustSql()
	Repeatables := make([]bool, 0, 32)

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var temp bool
	for rows.Next() {
		err = rows.Scan(&temp)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		Repeatables = append(Repeatables, temp)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return Repeatables, err
}
func (r *CommandRepository) GetRepeatAfter(ctx context.Context, opts ...FilterOpt) ([]*int, error) {
	return getRepeatAfter(ctx, r.db, opts...)
}

func (r *QueryRepository) GetRepeatAfter(ctx context.Context, opts ...FilterOpt) ([]*int, error) {
	return getRepeatAfter(ctx, r.db, opts...)
}

func getRepeatAfter(ctx context.Context, run common.Querier, opts ...FilterOpt) ([]*int, error) {
	b := sq.Select(
		ColumnTaskRepeatAfter,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)
	query, args := b.MustSql()
	RepeatAfters := make([]*int, 0, 32)

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var temp *int
	for rows.Next() {
		err = rows.Scan(&temp)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		RepeatAfters = append(RepeatAfters, temp)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return RepeatAfters, err
}
func (r *CommandRepository) GetDoBefore(ctx context.Context, opts ...FilterOpt) ([]*time.Time, error) {
	return getDoBefore(ctx, r.db, opts...)
}

func (r *QueryRepository) GetDoBefore(ctx context.Context, opts ...FilterOpt) ([]*time.Time, error) {
	return getDoBefore(ctx, r.db, opts...)
}

func getDoBefore(ctx context.Context, run common.Querier, opts ...FilterOpt) ([]*time.Time, error) {
	b := sq.Select(
		ColumnTaskDoBefore,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)
	query, args := b.MustSql()
	DoBefores := make([]*time.Time, 0, 32)

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var temp *time.Time
	for rows.Next() {
		err = rows.Scan(&temp)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		DoBefores = append(DoBefores, temp)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return DoBefores, err
}
func (r *CommandRepository) GetCreatedAt(ctx context.Context, opts ...FilterOpt) ([]time.Time, error) {
	return getCreatedAt(ctx, r.db, opts...)
}

func (r *QueryRepository) GetCreatedAt(ctx context.Context, opts ...FilterOpt) ([]time.Time, error) {
	return getCreatedAt(ctx, r.db, opts...)
}

func getCreatedAt(ctx context.Context, run common.Querier, opts ...FilterOpt) ([]time.Time, error) {
	b := sq.Select(
		ColumnTaskCreatedAt,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)
	query, args := b.MustSql()
	CreatedAts := make([]time.Time, 0, 32)

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var temp time.Time
	for rows.Next() {
		err = rows.Scan(&temp)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		CreatedAts = append(CreatedAts, temp)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return CreatedAts, err
}
func (r *CommandRepository) GetUpdatedAt(ctx context.Context, opts ...FilterOpt) ([]*time.Time, error) {
	return getUpdatedAt(ctx, r.db, opts...)
}

func (r *QueryRepository) GetUpdatedAt(ctx context.Context, opts ...FilterOpt) ([]*time.Time, error) {
	return getUpdatedAt(ctx, r.db, opts...)
}

func getUpdatedAt(ctx context.Context, run common.Querier, opts ...FilterOpt) ([]*time.Time, error) {
	b := sq.Select(
		ColumnTaskUpdatedAt,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)
	query, args := b.MustSql()
	UpdatedAts := make([]*time.Time, 0, 32)

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var temp *time.Time
	for rows.Next() {
		err = rows.Scan(&temp)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		UpdatedAts = append(UpdatedAts, temp)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return UpdatedAts, err
}

func (r *CommandRepository) GetLazy(ctx context.Context, opts ...FilterOpt) (iterTask, error) {
	return getManyLazy(ctx, r.db, opts...)
}

func (r *QueryRepository) GetLazy(ctx context.Context, opts ...FilterOpt) (iterTask, error) {
	return getManyLazy(ctx, r.db, opts...)
}

func getManyLazy(ctx context.Context, run common.Querier, opts ...FilterOpt) (iterTask, error) {
	b := sq.Select(
		ColumnTaskID,
		ColumnTaskName,
		ColumnTaskDescription,
		ColumnTaskCreatedBy,
		ColumnTaskDoer,
		ColumnTaskDone,
		ColumnTaskRepeatable,
		ColumnTaskRepeatAfter,
		ColumnTaskDoBefore,
		ColumnTaskCreatedAt,
		ColumnTaskUpdatedAt,
	).From(TableTask).PlaceholderFormat(sq.Question)

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)

	query, args := b.MustSql()

	rows, err := run.Query(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}

	return taskIter(rows), nil
}

func taskIter(rows common.Rows) iterTask {
	return func(yield func(Task) bool) {
		defer rows.Close()
		taskModel := &TaskModel{}
		for rows.Next() {
			err := rows.Scan(
				&taskModel.ID,
				&taskModel.Name,
				&taskModel.Description,
				&taskModel.CreatedBy,
				&taskModel.Doer,
				&taskModel.Done,
				&taskModel.Repeatable,
				&taskModel.RepeatAfter,
				&taskModel.DoBefore,
				&taskModel.CreatedAt,
				&taskModel.UpdatedAt,
			)
			if err != nil {
				return
			}

			if !yield(ReverseConverter(*taskModel)) {
				return
			}
		}
	}
}
