package builder

import (
	"fmt"
	"go/types"
	"os"
	"path/filepath"
	"strings"

	"github.com/AugustineAurelius/eos/pkg/errors"
	. "github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

func Generate(Source, StructName, Destination string) error {
	goPackage := os.Getenv("GOPACKAGE")

	f := NewFile(goPackage)
	f.PackageComment("Code generated by generator, DO NOT EDIT.")

	structType := parseStruct(Source, StructName)

	builderStructName := strings.ToLower(StructName) + "builder"

	f.Type().Id(builderStructName).Struct(
		Id("inner").Id(StructName),
	)

	f.Func().Id("New" + StructName + "Builder").Params().Op("*").Id(builderStructName).Block(
		Return().Op("&").Id(builderStructName).Block(),
	)

	builderMethod := Id("b").Op("*").Id(builderStructName)

	for i := 0; i < structType.NumFields(); i++ {
		field := structType.Field(i)

		titleName := strings.Title(field.Name())
		titleOfSetMethod := "Set" + titleName
		titleOfAddOneMethod := "AddOneTo" + titleName

		setBlock := Id("b").Dot("inner").Dot(field.Name()).Op("=").Id(field.Name())

		switch v := field.Type().(type) {
		case *types.Basic:
			handleBasic(f, v, builderMethod, setBlock, titleName, builderStructName, field)
		case *types.Named:
			handleNamedParam(f, v, builderMethod, setBlock, titleOfSetMethod, builderStructName, field)
		case *types.Slice:
			handleSlice(f, v, builderMethod, setBlock, titleOfSetMethod, titleOfAddOneMethod, builderStructName, field)

		default:
			return fmt.Errorf("struct field type not hanled: %T", v)
		}
	}

	f.Func().Params(builderMethod).
		Id("Build").Params().Id(StructName).
		Block(
			Return(Id("b").Dot("inner")),
		)

	goFile := os.Getenv("GOFILE")
	ext := filepath.Ext(goFile)
	baseFilename := goFile[0 : len(goFile)-len(ext)]
	targetFilename := baseFilename + "_gen.go"
	if Destination != "" {
		targetFilename = Destination
	}

	return f.Save(targetFilename)
}

func loadPackage(path string) *packages.Package {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		errors.FailErr(fmt.Errorf("loading packages for inspection: %v", err))
	}
	if packages.PrintErrors(pkgs) > 0 {
		os.Exit(1)
	}

	return pkgs[0]
}

func parseStruct(Source, StructName string) *types.Struct {
	pkg := loadPackage(Source)
	obj := pkg.Types.Scope().Lookup(StructName)
	if obj == nil {
		errors.FailErr(fmt.Errorf("%s not found in declared types of %s", StructName, pkg))
	}

	if _, ok := obj.(*types.TypeName); !ok {
		errors.FailErr(fmt.Errorf("%v is not a named type", obj))
	}

	structType, ok := obj.Type().Underlying().(*types.Struct)
	if !ok {
		errors.FailErr(fmt.Errorf("type %v is not a struct", obj))
	}

	return structType
}
func handleBasic(f *File, v *types.Basic, builderMethod, setBlock Code, titleOfSetMethod, builderStructName string, field *types.Var) {
	f.Func().Params(builderMethod).
		Id(titleOfSetMethod).Params(Id(field.Name()).Id(v.String())).Op("*").Id(builderStructName).
		Block(setBlock, Return(Id("b")))
}

func handleNamedParam(f *File, v *types.Named, builderMethod, setBlock Code, titleOfSetMethod, builderStructName string, field *types.Var) {
	typeName := v.Obj()

	if strings.Contains(typeName.Pkg().Path(), "command-line-arguments") {
		f.Func().Params(builderMethod).
			Id(titleOfSetMethod).Params(Id(field.Name()).Id(typeName.Name())).Op("*").Id(builderStructName).
			Block(setBlock, Return(Id("b")))
		return
	}

	f.Func().Params(builderMethod).
		Id(titleOfSetMethod).Params(Id(field.Name()).Qual(typeName.Pkg().Path(), typeName.Name())).Op("*").Id(builderStructName).
		Block(setBlock, Return(Id("b")))
}

func handleSlice(f *File, v *types.Slice, builderMethod, setBlock Code, titleOfSetMethod, titleOfAddOneMethod, builderStructName string, field *types.Var) {
	appendOne := Id("b").Dot("inner").Dot(field.Name()).Op("=").Append(Id("b").Dot("inner").Dot(field.Name()), Id("one"))

	switch s := v.Elem().(type) {
	case *types.Basic:
		f.Func().Params(builderMethod).
			Id(titleOfSetMethod).Params(Id(field.Name()).Index().Id(s.String())).Op("*").Id(builderStructName).
			Block(setBlock, Return(Id("b")))

		f.Func().Params(builderMethod).
			Id(titleOfAddOneMethod).Params(Id("one").Id(s.String())).Op("*").Id(builderStructName).
			Block(appendOne, Return(Id("b")))

	case *types.Named:
		typeName := s.Obj()

		f.Func().Params(builderMethod).
			Id(titleOfSetMethod).Params(Id(field.Name()).Index().Qual(typeName.Pkg().Path(), typeName.Name())).Op("*").Id(builderStructName).
			Block(setBlock, Return(Id("b")))

		f.Func().Params(builderMethod).
			Id(titleOfAddOneMethod).Params(Id("one").Qual(typeName.Pkg().Path(), typeName.Name())).Op("*").Id(builderStructName).
			Block(appendOne, Return(Id("b")))

	}

}
