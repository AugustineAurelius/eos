//Code generated by generator, DO NOT EDIT.
package main

import (
	"context"
	"database/sql"
	"errors"
	"fmt"

	"github.com/AugustineAurelius/eos/pkg/generics"
	sq "github.com/Masterminds/squirrel"
	"time"
	"github.com/shopspring/decimal"
)

type querier interface {
    ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
    QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
    QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

type wildcard int

const (
	QuestionWildcard wildcard = iota + 1
	DollarWildcard
)

type CommandRepository struct{
	runner querier
  	placeholder wildcard 
}

type QueryRepository struct{
	runner querier
  	placeholder wildcard 
}

func NewCommand(db querier, wildcards ...wildcard) *CommandRepository {
	w := QuestionWildcard 
	if len(wildcards) >0 {
		w = wildcards[0]
	}

	return &CommandRepository{
		runner: db,
    placeholder: w,
	}
}

func NewQuery(db querier, wildcards ...wildcard) *QueryRepository {
  	w := QuestionWildcard 
  	if len(wildcards) >0 {
    	w = wildcards[0]
  	}

	return &QueryRepository{
	    runner: db,
      	placeholder: w,
	}
}

// NavHistoryFiler represents the NavHistory filter.
type Filter struct {
	id *int
	notid *int
	gtid *int
	ltid *int
	gteqid *int
	lteqid *int
	ids []int
	idorderByAsc  *string
	idorderByDesc *string
	robotid *int64
	notrobotid *int64
	gtrobotid *int64
	ltrobotid *int64
	gteqrobotid *int64
	lteqrobotid *int64
	robotids []int64
	robotidorderByAsc  *string
	robotidorderByDesc *string
	nav *decimal.Decimal
	notnav *decimal.Decimal
	gtnav *decimal.Decimal
	ltnav *decimal.Decimal
	gteqnav *decimal.Decimal
	lteqnav *decimal.Decimal
	navs []decimal.Decimal
	navorderByAsc  *string
	navorderByDesc *string
	createdat *time.Time
	notcreatedat *time.Time
	gtcreatedat *time.Time
	ltcreatedat *time.Time
	gteqcreatedat *time.Time
	lteqcreatedat *time.Time
	createdats []time.Time
	createdatorderByAsc  *string
	createdatorderByDesc *string
	limit *int
	offset *int

}

type FilterOpt func(f *Filter)

func NewFilter(opts ...FilterOpt) Filter{
	f := Filter{}
	for _, opt := range opts {
		opt(&f)
	}
	return f
}

func WithLimit(limit int)  FilterOpt {
	c := limit
	return func(f *Filter) {
		f.limit = &c
	}
}
func WithOffset(offset int)  FilterOpt {
	c := offset
	return func(f *Filter) {
		f.offset = &c
	}
}
func WithID(id int)  FilterOpt {
	c := id
	return func(f *Filter) {
		f.id = &c
	}
}
func WithIDNot(id int)  FilterOpt {
	c := id
	return func(f *Filter) {
		f.notid = &c
	}
}
func WithIDMoreThen(id int)  FilterOpt {
	c := id
	return func(f *Filter) {
		f.gtid = &c
	}
}
func WithIDLowerThen(id int)  FilterOpt {
	c := id
	return func(f *Filter) {
		f.ltid = &c
	}
}
func WithIDMoreOrEqualThen(id int)  FilterOpt {
	c := id
	return func(f *Filter) {
		f.gteqid = &c
	}
}
func WithIDLowerOrEqualThen(id int)  FilterOpt {
	c := id
	return func(f *Filter) {
		f.lteqid = &c
	}
}
func WithIDs (ids ...int)  FilterOpt {
	return func(f *Filter) {
		f.ids = append(f.ids, ids...)
	}
}

func WithOrderByIDAsc()  FilterOpt {
	return func(f *Filter) {
		var column string = "id ASC"
		f.idorderByAsc =&column
	}
}
func WithOrderByIDDesc()  FilterOpt {
	return func(f *Filter) {
		var column string = "id DESC"
		f.idorderByDesc =&column
	}
}
func WithRobotID(robotid int64)  FilterOpt {
	c := robotid
	return func(f *Filter) {
		f.robotid = &c
	}
}
func WithRobotIDNot(robotid int64)  FilterOpt {
	c := robotid
	return func(f *Filter) {
		f.notrobotid = &c
	}
}
func WithRobotIDMoreThen(robotid int64)  FilterOpt {
	c := robotid
	return func(f *Filter) {
		f.gtrobotid = &c
	}
}
func WithRobotIDLowerThen(robotid int64)  FilterOpt {
	c := robotid
	return func(f *Filter) {
		f.ltrobotid = &c
	}
}
func WithRobotIDMoreOrEqualThen(robotid int64)  FilterOpt {
	c := robotid
	return func(f *Filter) {
		f.gteqrobotid = &c
	}
}
func WithRobotIDLowerOrEqualThen(robotid int64)  FilterOpt {
	c := robotid
	return func(f *Filter) {
		f.lteqrobotid = &c
	}
}
func WithRobotIDs (robotids ...int64)  FilterOpt {
	return func(f *Filter) {
		f.robotids = append(f.robotids, robotids...)
	}
}

func WithOrderByRobotIDAsc()  FilterOpt {
	return func(f *Filter) {
		var column string = "robot_id ASC"
		f.robotidorderByAsc =&column
	}
}
func WithOrderByRobotIDDesc()  FilterOpt {
	return func(f *Filter) {
		var column string = "robot_id DESC"
		f.robotidorderByDesc =&column
	}
}
func WithNav(nav decimal.Decimal)  FilterOpt {
	c := nav
	return func(f *Filter) {
		f.nav = &c
	}
}
func WithNavNot(nav decimal.Decimal)  FilterOpt {
	c := nav
	return func(f *Filter) {
		f.notnav = &c
	}
}
func WithNavMoreThen(nav decimal.Decimal)  FilterOpt {
	c := nav
	return func(f *Filter) {
		f.gtnav = &c
	}
}
func WithNavLowerThen(nav decimal.Decimal)  FilterOpt {
	c := nav
	return func(f *Filter) {
		f.ltnav = &c
	}
}
func WithNavMoreOrEqualThen(nav decimal.Decimal)  FilterOpt {
	c := nav
	return func(f *Filter) {
		f.gteqnav = &c
	}
}
func WithNavLowerOrEqualThen(nav decimal.Decimal)  FilterOpt {
	c := nav
	return func(f *Filter) {
		f.lteqnav = &c
	}
}
func WithNavs (navs ...decimal.Decimal)  FilterOpt {
	return func(f *Filter) {
		f.navs = append(f.navs, navs...)
	}
}

func WithOrderByNavAsc()  FilterOpt {
	return func(f *Filter) {
		var column string = "nav ASC"
		f.navorderByAsc =&column
	}
}
func WithOrderByNavDesc()  FilterOpt {
	return func(f *Filter) {
		var column string = "nav DESC"
		f.navorderByDesc =&column
	}
}
func WithCreatedAt(createdat time.Time)  FilterOpt {
	c := createdat
	return func(f *Filter) {
		f.createdat = &c
	}
}
func WithCreatedAtNot(createdat time.Time)  FilterOpt {
	c := createdat
	return func(f *Filter) {
		f.notcreatedat = &c
	}
}
func WithCreatedAtMoreThen(createdat time.Time)  FilterOpt {
	c := createdat
	return func(f *Filter) {
		f.gtcreatedat = &c
	}
}
func WithCreatedAtLowerThen(createdat time.Time)  FilterOpt {
	c := createdat
	return func(f *Filter) {
		f.ltcreatedat = &c
	}
}
func WithCreatedAtMoreOrEqualThen(createdat time.Time)  FilterOpt {
	c := createdat
	return func(f *Filter) {
		f.gteqcreatedat = &c
	}
}
func WithCreatedAtLowerOrEqualThen(createdat time.Time)  FilterOpt {
	c := createdat
	return func(f *Filter) {
		f.lteqcreatedat = &c
	}
}
func WithCreatedAts (createdats ...time.Time)  FilterOpt {
	return func(f *Filter) {
		f.createdats = append(f.createdats, createdats...)
	}
}

func WithOrderByCreatedAtAsc()  FilterOpt {
	return func(f *Filter) {
		var column string = "created_at ASC"
		f.createdatorderByAsc =&column
	}
}
func WithOrderByCreatedAtDesc()  FilterOpt {
	return func(f *Filter) {
		var column string = "created_at DESC"
		f.createdatorderByDesc =&column
	}
}

func applyWhere[B interface {
    Where(pred interface{}, args ...interface{}) B
	Limit(limit uint64) B
	Offset(limit uint64) B
	OrderBy(orderBys ...string) B
}](b B,f *Filter) B {
	if f.id != nil {
      b = b.Where(sq.Eq{ColumnNavHistoryID: *f.id})
    }
	if f.notid != nil {
      b = b.Where(sq.NotEq{ColumnNavHistoryID: *f.notid})
    }
	if f.ltid != nil {
      b = b.Where(sq.Lt{ColumnNavHistoryID: *f.ltid})
    }
	if f.gtid != nil {
      b = b.Where(sq.Gt{ColumnNavHistoryID: *f.gtid})
    }
	if f.lteqid != nil {
      b = b.Where(sq.LtOrEq{ColumnNavHistoryID: *f.lteqid})
    }
	if f.gteqid != nil {
      b = b.Where(sq.GtOrEq{ColumnNavHistoryID: *f.gteqid})
    }
	if f.ids != nil {
      b = b.Where(sq.Eq{ColumnNavHistoryID: f.ids})
    }
	if f.idorderByAsc != nil {
		b =b.OrderBy(*f.idorderByAsc)
	}
	if f.idorderByDesc != nil {
		b =b.OrderBy(*f.idorderByDesc)
	}
	if f.robotid != nil {
      b = b.Where(sq.Eq{ColumnNavHistoryRobotID: *f.robotid})
    }
	if f.notrobotid != nil {
      b = b.Where(sq.NotEq{ColumnNavHistoryRobotID: *f.notrobotid})
    }
	if f.ltrobotid != nil {
      b = b.Where(sq.Lt{ColumnNavHistoryRobotID: *f.ltrobotid})
    }
	if f.gtrobotid != nil {
      b = b.Where(sq.Gt{ColumnNavHistoryRobotID: *f.gtrobotid})
    }
	if f.lteqrobotid != nil {
      b = b.Where(sq.LtOrEq{ColumnNavHistoryRobotID: *f.lteqrobotid})
    }
	if f.gteqrobotid != nil {
      b = b.Where(sq.GtOrEq{ColumnNavHistoryRobotID: *f.gteqrobotid})
    }
	if f.robotids != nil {
      b = b.Where(sq.Eq{ColumnNavHistoryRobotID: f.robotids})
    }
	if f.robotidorderByAsc != nil {
		b =b.OrderBy(*f.robotidorderByAsc)
	}
	if f.robotidorderByDesc != nil {
		b =b.OrderBy(*f.robotidorderByDesc)
	}
	if f.nav != nil {
      b = b.Where(sq.Eq{ColumnNavHistoryNav: *f.nav})
    }
	if f.notnav != nil {
      b = b.Where(sq.NotEq{ColumnNavHistoryNav: *f.notnav})
    }
	if f.ltnav != nil {
      b = b.Where(sq.Lt{ColumnNavHistoryNav: *f.ltnav})
    }
	if f.gtnav != nil {
      b = b.Where(sq.Gt{ColumnNavHistoryNav: *f.gtnav})
    }
	if f.lteqnav != nil {
      b = b.Where(sq.LtOrEq{ColumnNavHistoryNav: *f.lteqnav})
    }
	if f.gteqnav != nil {
      b = b.Where(sq.GtOrEq{ColumnNavHistoryNav: *f.gteqnav})
    }
	if f.navs != nil {
      b = b.Where(sq.Eq{ColumnNavHistoryNav: f.navs})
    }
	if f.navorderByAsc != nil {
		b =b.OrderBy(*f.navorderByAsc)
	}
	if f.navorderByDesc != nil {
		b =b.OrderBy(*f.navorderByDesc)
	}
	if f.createdat != nil {
      b = b.Where(sq.Eq{ColumnNavHistoryCreatedAt: *f.createdat})
    }
	if f.notcreatedat != nil {
      b = b.Where(sq.NotEq{ColumnNavHistoryCreatedAt: *f.notcreatedat})
    }
	if f.ltcreatedat != nil {
      b = b.Where(sq.Lt{ColumnNavHistoryCreatedAt: *f.ltcreatedat})
    }
	if f.gtcreatedat != nil {
      b = b.Where(sq.Gt{ColumnNavHistoryCreatedAt: *f.gtcreatedat})
    }
	if f.lteqcreatedat != nil {
      b = b.Where(sq.LtOrEq{ColumnNavHistoryCreatedAt: *f.lteqcreatedat})
    }
	if f.gteqcreatedat != nil {
      b = b.Where(sq.GtOrEq{ColumnNavHistoryCreatedAt: *f.gteqcreatedat})
    }
	if f.createdats != nil {
      b = b.Where(sq.Eq{ColumnNavHistoryCreatedAt: f.createdats})
    }
	if f.createdatorderByAsc != nil {
		b =b.OrderBy(*f.createdatorderByAsc)
	}
	if f.createdatorderByDesc != nil {
		b =b.OrderBy(*f.createdatorderByDesc)
	}

	if f.limit != nil {
		b  = b.Limit(uint64(*f.limit))
	}
	if f.offset != nil {
		b  = b.Offset(uint64(*f.offset))
	}

  return b
}

type UpdateOpt func(u *Update)

// NavHistoryUpdate represents the NavHistory update struct.
type Update struct {
  id *int
  robotid *int64
  nav *decimal.Decimal
  createdat *time.Time
}

func NewUpdate(opts ...UpdateOpt) Update{
	u := &Update{}
	for _, opt := range opts {
		opt(u)
	}
	return *u
}
func WithUpdateID(id int)  UpdateOpt {
	return func(f *Update) {
		f.id = &id
	}
}
func WithUpdateRobotID(robotid int64)  UpdateOpt {
	return func(f *Update) {
		f.robotid = &robotid
	}
}
func WithUpdateNav(nav decimal.Decimal)  UpdateOpt {
	return func(f *Update) {
		f.nav = &nav
	}
}
func WithUpdateCreatedAt(createdat time.Time)  UpdateOpt {
	return func(f *Update) {
		f.createdat = &createdat
	}
}

func applySet[B interface {
    Set(column string, value interface{}) B
}] (b B, f *Update) B {
	if f.id != nil {
      b = b.Set(ColumnNavHistoryID, *f.id)
    }
	if f.robotid != nil {
      b = b.Set(ColumnNavHistoryRobotID, *f.robotid)
    }
	if f.nav != nil {
      b = b.Set(ColumnNavHistoryNav, *f.nav)
    }
	if f.createdat != nil {
      b = b.Set(ColumnNavHistoryCreatedAt, *f.createdat)
    }

  return b
}

// CreateNavHistory inserts a new NavHistory into the database.
func (r *CommandRepository) Create(ctx context.Context, model *NavHistory) error {
  	var query string
  	var args []any
  
	switch r.placeholder {
	case DollarWildcard:
		query, args = sq.Insert(TableNavHistory).Columns(ColumnNavHistoryRobotID, ColumnNavHistoryNav, ColumnNavHistoryCreatedAt).Values(model.RobotID, model.Nav, model.CreatedAt). PlaceholderFormat(sq.Dollar).MustSql()
  	default:
		query, args = sq.Insert(TableNavHistory).Columns(ColumnNavHistoryRobotID, ColumnNavHistoryNav, ColumnNavHistoryCreatedAt).Values(model.RobotID, model.Nav, model.CreatedAt).PlaceholderFormat(sq.Question).MustSql()	
  	}

	if _, err := r.runner.ExecContext(ctx, query, args...); err != nil {
		return fmt.Errorf("failed to exec create query %s with args %v error = %w", query, args, err)
	}
	return nil
}

// CreateManyNavHistory inserts multiple NavHistorys into the database.
func (r *CommandRepository) CreateMany(ctx context.Context, navhistorys []NavHistory) error {
  	var builder sq.InsertBuilder

	switch r.placeholder {
	case DollarWildcard:
	  	builder = sq.Insert(TableNavHistory).Columns(ColumnNavHistoryRobotID, ColumnNavHistoryNav, ColumnNavHistoryCreatedAt).PlaceholderFormat(sq.Dollar)
  	default:
	  	builder = sq.Insert(TableNavHistory).Columns(ColumnNavHistoryRobotID, ColumnNavHistoryNav, ColumnNavHistoryCreatedAt).PlaceholderFormat(sq.Question)
  	}

  	for _, model := range navhistorys {
    	builder = builder.Values(model.RobotID, model.Nav, model.CreatedAt)
  	}
	query, args := builder.MustSql()

	if _, err := r.runner.ExecContext(ctx, query, args...); err != nil {
		return fmt.Errorf("failed to exec create query %s with args %v error = %w", query, args, err)
	}
	return nil
}

// UpdateNavHistory updates an existing NavHistory in the database.
func (r *CommandRepository) Update(ctx context.Context, u Update, opts ...FilterOpt) error {
  	var b sq.UpdateBuilder
	switch r.placeholder {
	case DollarWildcard:
	  	b = sq.Update(TableNavHistory).PlaceholderFormat(sq.Dollar)
  	default:
	  	b = sq.Update(TableNavHistory).PlaceholderFormat(sq.Question)
  	}

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)
  	b = applySet(b, &u)

	query, args := b.MustSql()
	if _, err := r.runner.ExecContext(ctx, query, args...); err != nil {
		return fmt.Errorf("failed to exec update query %s with args %v", query, args)
	}
	return nil 
}

// UpsertNavHistory inserts a new NavHistory or updates an existing one.
func (r *CommandRepository) Upsert(ctx context.Context, model *NavHistory) error {
	var query string
	var args []any

	switch r.placeholder {
	case DollarWildcard:
		query, args = sq.Insert(TableNavHistory).
			Columns(ColumnNavHistoryRobotID, ColumnNavHistoryNav, ColumnNavHistoryCreatedAt).
			Values(model.RobotID, model.Nav, model.CreatedAt).
			Suffix("ON CONFLICT (id) DO UPDATE SET robot_id = EXCLUDED.robot_id, nav = EXCLUDED.nav, created_at = EXCLUDED.created_at").
			PlaceholderFormat(sq.Dollar).
			MustSql()
	default:
		query, args = sq.Insert(TableNavHistory).
			Columns(ColumnNavHistoryRobotID, ColumnNavHistoryNav, ColumnNavHistoryCreatedAt).
			Values(model.RobotID, model.Nav, model.CreatedAt).
			Suffix("ON CONFLICT (id) DO UPDATE SET robot_id = EXCLUDED.robot_id, nav = EXCLUDED.nav, created_at = EXCLUDED.created_at").
			PlaceholderFormat(sq.Question).
			MustSql()
	}

	if _, err := r.runner.ExecContext(ctx, query, args...); err != nil {
		return fmt.Errorf("failed to exec upsert query %s with args %v error = %w", query, args, err)
	}
	return nil
}
// SaveNavHistory saves a NavHistory (creates if ID is zero, updates otherwise).
func (r *CommandRepository) Save(ctx context.Context, model *NavHistory) error {
	if model.ID == 0 {
		return r.Create(ctx, model)
	}
	return r.Update(ctx, NewUpdate(WithUpdateRobotID(model.RobotID), WithUpdateNav(model.Nav), WithUpdateCreatedAt(model.CreatedAt)), WithID(model.ID))
}

// DeleteNavHistory deletes NavHistorys from the database.
func (r *CommandRepository) Delete(ctx context.Context, opts ...FilterOpt) error {
	var b sq.DeleteBuilder
	switch r.placeholder {
	case DollarWildcard:
		b = sq.Delete(TableNavHistory).PlaceholderFormat(sq.Dollar)
	default:
		b = sq.Delete(TableNavHistory).PlaceholderFormat(sq.Question)
	}

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

	query, args := b.MustSql()
	if _, err := r.runner.ExecContext(ctx, query, args...); err != nil {
		return fmt.Errorf("failed to exec delete query %s with args %v", query, args)
	}
	return nil
}

// GetNavHistory retrieves a single NavHistory from the database.
func (r *CommandRepository) Get(ctx context.Context, opts ...FilterOpt) (*NavHistory, error) {
	return get(ctx, r.runner, r.placeholder, opts...)
}

func (r *QueryRepository) Get(ctx context.Context, opts ...FilterOpt) (*NavHistory, error) {
	return get(ctx, r.runner, r.placeholder, opts...)
}

func get(ctx context.Context, run querier, placeholder wildcard, opts ...FilterOpt) (*NavHistory, error){
  	var b sq.SelectBuilder

	switch placeholder {
	case DollarWildcard:
		b = sq.Select(ColumnNavHistoryID, ColumnNavHistoryRobotID, ColumnNavHistoryNav, ColumnNavHistoryCreatedAt).From(TableNavHistory).PlaceholderFormat(sq.Dollar)
	default:
		b = sq.Select(ColumnNavHistoryID, ColumnNavHistoryRobotID, ColumnNavHistoryNav, ColumnNavHistoryCreatedAt).From(TableNavHistory).PlaceholderFormat(sq.Question)
	}
  
	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

  	query, args := b.MustSql()

	var model NavHistory
	err := run.QueryRowContext(ctx, query, args...).Scan(&model.ID, &model.RobotID, &model.Nav, &model.CreatedAt)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("navhistory not found")
		}
		return nil, fmt.Errorf("failed to get query %s with args %v error = %w" , query, args, err)
	}

	return &model, err
}

// GetManyNavHistory retrieves multiple NavHistorys from the database.
func (r *CommandRepository) GetMany(ctx context.Context, opts ...FilterOpt) (generics.SliceOps[NavHistory], error) {
	return getMany(ctx, r.runner, r.placeholder, opts...)
}

func (r *QueryRepository) GetMany(ctx context.Context, opts ...FilterOpt) (generics.SliceOps[NavHistory], error) {
	return getMany(ctx, r.runner, r.placeholder, opts...)
}

func getMany(ctx context.Context, run querier, placeholder wildcard,  opts ...FilterOpt) (generics.SliceOps[NavHistory], error) {
  	var b sq.SelectBuilder

	switch placeholder {
	case DollarWildcard:
		b = sq.Select(ColumnNavHistoryID, ColumnNavHistoryRobotID, ColumnNavHistoryNav, ColumnNavHistoryCreatedAt).From(TableNavHistory).PlaceholderFormat(sq.Dollar)  
	default:
		b = sq.Select(ColumnNavHistoryID, ColumnNavHistoryRobotID, ColumnNavHistoryNav, ColumnNavHistoryCreatedAt).From(TableNavHistory).PlaceholderFormat(sq.Question)
	}

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

 	query, args := b.MustSql()

  	var navhistorys generics.SliceOps[NavHistory]
	rows, err := run.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var model NavHistory
	for rows.Next() {
		err = rows.Scan(&model.ID, &model.RobotID, &model.Nav, &model.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		navhistorys = append(navhistorys, model)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return navhistorys, err
}

// HasNavHistory checks if a NavHistory exists in the database.
func (r *CommandRepository) Has(ctx context.Context, opts ...FilterOpt) (bool, error) {
	return has(ctx, r.runner, r.placeholder, opts...)
}

func (r *QueryRepository) Has(ctx context.Context, opts ...FilterOpt) (bool, error) {
	return has(ctx, r.runner, r.placeholder, opts...)
}

func has(ctx context.Context, run querier, placeholder wildcard, opts ...FilterOpt) (bool, error) {
	var b sq.SelectBuilder

	switch placeholder {
	case DollarWildcard:
		b = sq.Select("1").From(TableNavHistory).PlaceholderFormat(sq.Dollar)
	default:
		b = sq.Select("1").From(TableNavHistory).PlaceholderFormat(sq.Question)
	}

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)
	b = b.Limit(1)

	query, args := b.MustSql()

	var exists int
	err := run.QueryRowContext(ctx, query, args...).Scan(&exists)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return false, nil
		}
		return false, fmt.Errorf("failed to check existence query %s with args %v error = %w", query, args, err)
	}

	return true, nil
}

// GetIteratorNavHistory returns an iterator for NavHistorys.
func (r *CommandRepository) GetIterator(ctx context.Context, opts ...FilterOpt) generics.IterWithErr[NavHistory] {
	return getIterator(ctx, r.runner, r.placeholder, opts...)
}

func (r *QueryRepository) GetIterator(ctx context.Context, opts ...FilterOpt) generics.IterWithErr[NavHistory] {
	return getIterator(ctx, r.runner, r.placeholder, opts...)
}

func getIterator(ctx context.Context, run querier, placeholder wildcard, opts ...FilterOpt) generics.IterWithErr[NavHistory] {
	return func(yield func(NavHistory, error) bool) {
		pageSize := 100
		offset := 0

		f := Filter{}
		for i := 0; i < len(opts); i++ {
			opts[i](&f)
		}

		if f.limit != nil && *f.limit > 0 {
			pageSize = *f.limit
		}

		for {
			pageOpts := make([]FilterOpt, 0, len(opts)+2)
			pageOpts = append(pageOpts, opts...)
			pageOpts = append(pageOpts, WithLimit(pageSize))
			pageOpts = append(pageOpts, WithOffset(offset))

			navhistorys, err := getMany(ctx, run, placeholder, pageOpts...)
			if err != nil {
				yield(NavHistory{}, err)
				return
			}

			if len(navhistorys) == 0 {
				break
			}

			for _, navhistory := range navhistorys {
				if !yield(navhistory, nil) {
					return
				}
			}

			if len(navhistorys) < pageSize {
				break
			}

			offset += pageSize
		}
	}
}

// CountNavHistory counts NavHistorys in the database.
func (r *CommandRepository) Count(ctx context.Context, opts ...FilterOpt) (int, error) {
	return count(ctx, r.runner, r.placeholder, opts...)
}

func (r *QueryRepository) Count(ctx context.Context, opts ...FilterOpt) (int, error) {
	return count(ctx, r.runner, r.placeholder, opts...)
}

func count(ctx context.Context, run querier, placeholder wildcard, opts ...FilterOpt) (int, error) {
	var b sq.SelectBuilder

	switch placeholder {
	case DollarWildcard:
    	b = sq.Select("COUNT (1)").From(TableNavHistory).PlaceholderFormat(sq.Dollar)
	default:
    	b = sq.Select("COUNT (1)").From(TableNavHistory).PlaceholderFormat(sq.Question)
	}

  	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

  	query, args := b.MustSql()

  	var count int
  	err := run.QueryRowContext(ctx, query,args...).Scan(&count)
  	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return 0, nil
		}
    	return 0, fmt.Errorf("failed to count query %s with args %v error = %w" , query, args, err)
  	}

  	return count, nil
}


func (r *CommandRepository) NewCursor(ctx context.Context,  params BuilderParams, opts ...FilterOpt) *Cursor {
	limit := 10
	if params.Limit != nil {
		limit = *params.Limit
	}

	offset := 0
	if params.Offset != nil {
		offset = *params.Offset
	}
  var b sq.SelectBuilder
  switch r.placeholder {
	case DollarWildcard:
	  b = sq.Select(
		ColumnNavHistoryID,
		ColumnNavHistoryRobotID,
		ColumnNavHistoryNav,
		ColumnNavHistoryCreatedAt,
	  ).From(TableNavHistory).PlaceholderFormat(sq.Dollar)
  default:
	  b = sq.Select(
		ColumnNavHistoryID,
		ColumnNavHistoryRobotID,
		ColumnNavHistoryNav,
		ColumnNavHistoryCreatedAt,
	  ).From(TableNavHistory).PlaceholderFormat(sq.Question)
  }

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

	return &Cursor{
		pool:      r.runner,
		builder:   b,
		rows:      make([]NavHistory, 0, limit),
		index:    -1,
		offset:   offset,
		limit:    limit,
		params:   params,
		ctx:      ctx,
		totalRows: 0,
		closed:    false,
	}
}

func (r *QueryRepository) NewCursor(ctx context.Context,  params BuilderParams, opts ...FilterOpt) *Cursor {
	limit := 10
	if params.Limit != nil {
		limit = *params.Limit
	}

	offset := 0
	if params.Offset != nil {
		offset = *params.Offset
	}

  var b sq.SelectBuilder
  switch r.placeholder {
	case DollarWildcard:
	  b = sq.Select(
		ColumnNavHistoryID,
		ColumnNavHistoryRobotID,
		ColumnNavHistoryNav,
		ColumnNavHistoryCreatedAt,
	  ).From(TableNavHistory).PlaceholderFormat(sq.Dollar)
  default:
	  b = sq.Select(
		ColumnNavHistoryID,
		ColumnNavHistoryRobotID,
		ColumnNavHistoryNav,
		ColumnNavHistoryCreatedAt,
	  ).From(TableNavHistory).PlaceholderFormat(sq.Question)
  }

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

	return &Cursor{
		pool:      r.runner,
		builder:   b,
		rows:      make([]NavHistory, 0, limit),
		index:    -1,
		offset:   offset,
		limit:    limit,
		params:   params,
		ctx:      ctx,
		totalRows: 0,
		closed:    false,
	}
}

func (c *Cursor) fetchRows() error {
	if c.closed {
		return errors.New("cursor is closed")
	}

	// Check if we've reached the maximum number of rows
	if c.params.MaxRows != nil && c.totalRows >= *c.params.MaxRows {
		return nil // No more rows to fetch
	}
	builder := c.builder

	if c.params.SearchCol != nil && c.params.SearchTerm != nil {
		builder = builder.Where(sq.ILike{*c.params.SearchCol: fmt.Sprintf("%%%s%%", *c.params.SearchTerm)})
	}

	if c.params.OrderBy != nil {
		builder = builder.OrderBy(*c.params.OrderBy)
	}
	remainingRows := c.limit
	if c.params.MaxRows != nil {
		remainingRows = *c.params.MaxRows - c.totalRows
		if remainingRows <= 0 {
			return nil 		
		}
		if remainingRows > c.limit {
			remainingRows = c.limit
		}
	}

	builder = builder.Limit(uint64(remainingRows)).Offset(uint64(c.offset))

	sql, args, err := builder.ToSql()
	if err != nil {
		return err
	}

	rows, err := c.pool.QueryContext(c.ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	c.rows = make([]NavHistory, 0,c.limit)
	for rows.Next() {
		var item NavHistory
		err := rows.Scan(
			&item.ID,
			&item.RobotID,
			&item.Nav,
			&item.CreatedAt,
		)
		if err != nil {
			return fmt.Errorf("error scanning row: %w", err)
		}
		c.totalRows++
		c.rows = append(c.rows, item)
	}

	if len(c.rows) > 0 {
		c.offset += remainingRows
	}
	return nil
}

func (c *Cursor) Next() bool {
	if c.closed {
		return false
	}

	// Check if we've reached the maximum number of rows
	if c.params.MaxRows != nil && c.totalRows >= *c.params.MaxRows && c.index >= len(c.rows)-1 {
		return false
	}
	if c.index >= len(c.rows)-1 {
		if err := c.fetchRows(); err != nil || len(c.rows) == 0 {
			return false
		}
		c.index = 0
		return true
	}

	c.index++
	return true
}

func (c *Cursor) Prev() bool {
	if c.closed {
		return false
	}
	if c.index > 0 {
		c.index--
		return true
	}
	return false
}

func (c *Cursor) Current() (NavHistory, error) {
	if c.closed {
		return NavHistory{}, errors.New("cursor is closed")
	}

	if c.index >= 0 && c.index < len(c.rows) {
		return c.rows[c.index], nil
	}
	return NavHistory{} , errors.New("not found")
}

func (c *Cursor) Reset() {
	if c.closed {
		return
	}

	c.index = -1
	c.offset = 0
	c.totalRows = 0
	c.rows = c.rows[:0] // Clear the slice while keeping the underlying array
}

// Close releases all resources held by the cursor.
func (c *Cursor) Close() {
	if c.closed {
		return
	}

	c.rows = nil // Free the memory held by the rows slice
	c.closed = true
}
