package {{.PackageName}}

import (
	"context"
	"errors"
	"time"


	"github.com/prometheus/client_golang/prometheus"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/trace"
	"go.uber.org/zap"
)


type {{.Name}}Interface interface {
	{{- range .Methods}}
    {{.Name}}{{.Signature}}
	{{- end}}
}

type {{.Name | firstToLower}}Core struct {
	impl *{{.Name}}
}

{{range .Methods}}
func (c *{{$.Name | firstToLower}}Core) {{.Name}}{{.Signature}} {
	return c.impl.{{.Name}}({{ join .Params  ","}})
}
{{end}}

// Main constructor
func New{{.Name}}Middleware(impl *{{.Name}}, opts ...{{.Name}}Option) {{.Name}}Interface {
	chain := {{.Name}}Interface(&{{.Name | firstToLower}}Core{impl})
	for _, opt := range opts {
		chain = opt(chain)
	}
	return chain
}

// Option
type {{.Name}}Option func({{.Name}}Interface) {{.Name}}Interface

//Logging
type {{.Name | firstToLower}}LoggingMiddleware struct {
	next   {{.Name}}Interface
	logger *zap.Logger
}

func With{{.Name}}Logging(logger *zap.Logger) {{.Name}}Option {
	return func(next {{.Name}}Interface) {{.Name}}Interface {
		return &{{.Name | firstToLower}}LoggingMiddleware{
			next:   next,
			logger: logger.With(zap.String("struct", "{{.Name}}")),
		}
	}
}

{{range .Methods}}
func (m *{{$.Name | firstToLower}}LoggingMiddleware) {{.Name}}{{.Signature}} {
    start := time.Now()
    m.logger.Info("call {{.Name}}", 
    {{- range .InputObjects -}}
    {{- if eq .ZapType "Any"}}
    {{- else -}}
        zap.{{.ZapType}}("{{.Name}}", {{.Name}}),
    {{- end}}
    {{- end}})
    defer func() { m.logger.Info("method {{.Name}} call done", zap.Duration("diration", time.Since(start)),
    {{- range .OutputObjects}}
    {{- if eq .ZapType  "Error" -}} 
        zap.{{.ZapType}}({{.Name}}),
    {{- else -}}
        zap.{{.ZapType}}("{{.Name}}", {{.Name}}),
    {{- end}}
    {{- end}})}()

    return m.next.{{.Name}}({{ join .Params  ","}})
}
{{end}}

// Tracing
type {{.Name | firstToLower}}TracingMiddleware struct {
	next   {{.Name}}Interface
	tracer trace.Tracer
}

func With{{.Name | firstToLower}}Tracing(tracer trace.Tracer) {{.Name}}Option {
	return func(next {{.Name}}Interface) {{.Name}}Interface {
		return &{{.Name | firstToLower}}TracingMiddleware{
			next:   next,
			tracer: tracer,
		}
	}
}

{{range .Methods}}
func (m *{{$.Name | firstToLower}}TracingMiddleware){{.Name}} {{.Signature}} {
	{{if .HasContext -}}
	ctx, span := m.tracer.Start(ctx, "{{$.Name}}.{{.Name}}")
	defer span.End()
	{{else -}}
	_, span := m.tracer.Start(context.Background(), "{{$.Name}}.{{.Name}}")
	defer span.End()
	{{end -}}

	return m.next.{{.Name}}({{ join .Params  ","}})
}
{{end}}


// Timeout
type {{.Name | firstToLower}}TimeoutMiddleware struct {
	{{.Name}}Interface
	duration time.Duration
}
// if method has context as param timeout would be applied
func With{{.Name | firstToLower}}Timeout(duration time.Duration) {{.Name}}Option {
	return func(next {{.Name}}Interface) {{.Name}}Interface {
		return &{{.Name | firstToLower}}TimeoutMiddleware{
			{{.Name}}Interface:   next,
			duration: duration,
		}
	}
}

{{range .Methods}}
{{if .HasContext -}}
func (m *{{$.Name | firstToLower}}TimeoutMiddleware){{.Name}} {{.Signature}} {
	ctx, cancel := context.WithTimeout(ctx, m.duration)
	defer cancel()
	return m.{{$.Name}}Interface.{{.Name}}({{ join .Params  ","}})
}
{{end -}}
{{end}}
type {{.Name | firstToLower}}OtelMetricsRegister struct {
    meter       metric.Meter
    Duration    metric.Float64Histogram
    Calls       metric.Int64Counter
    Errors      metric.Int64Counter
    InFlight    metric.Int64UpDownCounter
}

func Register{{.Name}}OtelMetrics(provider metric.MeterProvider) *{{.Name | firstToLower}}OtelMetricsRegister {
    meter := provider.Meter("{{.Name | firstToLower}}/metrics")
    
    duration, _ := meter.Float64Histogram(
        "{{.Name | firstToLower}}_method_duration_seconds",
        metric.WithDescription("Method execution time distribution"),
        metric.WithUnit("s"),
        metric.WithExplicitBucketBoundaries(0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10),
    )

    calls, _ := meter.Int64Counter(
        "{{.Name | firstToLower}}_method_calls_total",
        metric.WithDescription("Total number of method calls"),
    )

    errors, _ := meter.Int64Counter(
        "{{.Name | firstToLower}}_method_errors_total",
        metric.WithDescription("Total number of method errors"),
    )

    inflight, _ := meter.Int64UpDownCounter(
        "{{.Name | firstToLower}}_method_in_flight",
        metric.WithDescription("Current number of executing methods"),
    )

    return &{{.Name | firstToLower}}OtelMetricsRegister{
        meter:     meter,
        Duration:  duration,
        Calls:     calls,
        Errors:    errors,
        InFlight:  inflight,
    }
}

type {{.Name | firstToLower}}OtelMetrics struct {
    {{.Name}}Interface
    metrics *{{.Name | firstToLower}}OtelMetricsRegister
}

func With{{.Name}}OtelMetrics(metrics *{{.Name | firstToLower}}OtelMetricsRegister) {{.Name}}Option {
    return func(next {{.Name}}Interface) {{.Name}}Interface {
        return &{{.Name | firstToLower}}OtelMetrics{
            {{.Name}}Interface:    next,
            metrics: metrics,
        }
    }
}

{{range .Methods}}
{{- if .HasError}}
{{- if .HasContext}}
func (m *{{$.Name | firstToLower}}OtelMetrics) {{.Name}} {{.Signature}}{
    start := time.Now()
    methodName := "{{.Name}}"
    commonAttrs := []attribute.KeyValue{
        attribute.String("method", methodName),
    }

    // Track in-flight requests
    m.metrics.InFlight.Add(ctx, 1)
    defer m.metrics.InFlight.Add(ctx, -1)

    // Increment call counter
    m.metrics.Calls.Add(ctx, 1, metric.WithAttributes(commonAttrs...))

    defer func() {
        duration := time.Since(start).Seconds()
        m.metrics.Duration.Record(ctx, duration, metric.WithAttributes(commonAttrs...))

        if {{.ErrorParam}} != nil {
            errorType := {{.ErrorParam}}.Error()
            switch {
            case errors.Is({{.ErrorParam}}, context.Canceled):
                errorType = "context_canceled"
            case errors.Is({{.ErrorParam}}, context.DeadlineExceeded):
                errorType = "timeout"
            }
            
            errorAttrs := append(commonAttrs, attribute.String("error_type", errorType))
            m.metrics.Errors.Add(ctx, 1, metric.WithAttributes(errorAttrs...))
        }

        if r := recover(); r != nil {
            errorAttrs := append(commonAttrs, attribute.String("error_type", "panic"))
            m.metrics.Errors.Add(ctx, 1, metric.WithAttributes(errorAttrs...))
            panic(r) // Re-throw panic after recording
        }
    }()

    return m.{{$.Name}}Interface.{{.Name}}({{ join .Params  ","}})
}
{{- end}}
{{- end}}
{{end}}


type {{.Name | firstToLower}}Metrics struct {
    Duration   *prometheus.HistogramVec
    Calls      *prometheus.CounterVec
    Errors     *prometheus.CounterVec
    InFlight   prometheus.Gauge
}

func Register{{.Name}}Metrics(registry prometheus.Registerer) *{{.Name | firstToLower}}Metrics {
    metrics := &{{.Name | firstToLower}}Metrics{
        Duration: prometheus.NewHistogramVec(prometheus.HistogramOpts{
            Name: "{{.Name | firstToLower}}_method_duration_seconds",
            Help: "Method execution time distribution",
            Buckets: []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10},
        }, []string{"method"}),
        
        Calls: prometheus.NewCounterVec(prometheus.CounterOpts{
            Name: "{{.Name | firstToLower}}_method_calls_total",
            Help: "Total number of method calls",
        }, []string{"method"}),
        
        Errors: prometheus.NewCounterVec(prometheus.CounterOpts{
            Name: "{{.Name | firstToLower}}_method_errors_total",
            Help: "Total number of method errors",
        }, []string{"method", "error_type"}),
        
        InFlight: prometheus.NewGauge(prometheus.GaugeOpts{
            Name: "{{.Name | firstToLower}}_method_in_flight",
            Help: "Current number of executing methods",
        }),
    }

    registry.MustRegister(
        metrics.Duration,
        metrics.Calls,
        metrics.Errors,
        metrics.InFlight,
    )
    
    return metrics
}

type {{.Name | firstToLower}}MetricsMiddleware struct {
    next    {{.Name}}Interface
    metrics *{{.Name | firstToLower}}Metrics
}

func With{{.Name}}Metrics(metrics *{{.Name | firstToLower}}Metrics) {{.Name}}Option {
    return func(next {{.Name}}Interface) {{.Name}}Interface {
        return &{{.Name | firstToLower}}MetricsMiddleware{
            next:    next,
            metrics: metrics,
        }
    }
}

{{range .Methods}}

{{- if .HasError}}
func (m *{{$.Name | firstToLower}}MetricsMiddleware) {{.Name}} {{.Signature}}{
    start := time.Now()
    methodName := "{{.Name}}"
    
    m.metrics.InFlight.Inc()
    defer m.metrics.InFlight.Dec()
    m.metrics.Calls.WithLabelValues(methodName).Inc()

	defer func(){
	    duration := time.Since(start).Seconds()
        m.metrics.Duration.WithLabelValues(methodName).Observe(duration)
		if {{.ErrorParam}} != nil {
			errorType := {{.ErrorParam}}.Error()
			switch {
			case errors.Is({{.ErrorParam}}, context.Canceled):
				errorType = "context_canceled"
			case errors.Is({{.ErrorParam}}, context.DeadlineExceeded):
				errorType = "timeout"
			}
        	m.metrics.Errors.WithLabelValues(methodName, errorType).Inc()
    	}
		if r := recover(); r != nil {
            m.metrics.Errors.WithLabelValues(methodName, "panic").Inc()
        }
	}()
    return m.next.{{.Name}}({{ join .Params  ","}})
}
{{- end}}

{{end}}