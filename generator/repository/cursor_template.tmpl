// Code generated by go generate; DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"fmt"
	"errors"


	sq "github.com/Masterminds/squirrel"
)

// builderParams represents optional query parameters.
type BuilderParams struct {
	OrderBy   *string // Column and direction for sorting (e.g., "id ASC")
	SearchCol *string // Column to search in (e.g., "name")
	SearchTerm *string // Term to search for (e.g., "alice")
	Offset    *int    // Initial offset for pagination
	Limit     *int    // Number of rows to fetch per batch
	MaxRows    *int
}

type Cursor struct {
	pool      querier 
	builder   sq.SelectBuilder
	rows      []{{.MessageName}}
	index     int
	offset    int
	limit     int
	params    BuilderParams
	ctx       context.Context
	totalRows int 
	closed    bool 
}

func (r *CommandRepository) NewCursor(ctx context.Context,  params BuilderParams, opts ...FilterOpt) *Cursor {
	limit := 10
	if params.Limit != nil {
		limit = *params.Limit
	}

	offset := 0
	if params.Offset != nil {
		offset = *params.Offset
	}
  var b sq.SelectBuilder
  switch r.placeholder {
	case DollarWildcard:
	  b = sq.Select(
		{{- range .Fields }}
		Column{{$.MessageName}}{{.Name}},
		{{- end }}
	  ).From(Table{{.MessageName}}).PlaceholderFormat(sq.Dollar)
  default:
	  b = sq.Select(
		{{- range .Fields }}
		Column{{$.MessageName}}{{.Name}},
		{{- end }}
	  ).From(Table{{.MessageName}}).PlaceholderFormat(sq.Question)
  }



	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)

	return &Cursor{
		pool:      r.runner,
		builder:   b,
		rows:      make([]{{.MessageName}}, 0, limit),
		index:    -1,
		offset:   offset,
		limit:    limit,
		params:   params,
		ctx:      ctx,
		totalRows: 0,
		closed:    false,
	}
}

func (r *QueryRepository) NewCursor(ctx context.Context,  params BuilderParams, opts ...FilterOpt) *Cursor {
	limit := 10
	if params.Limit != nil {
		limit = *params.Limit
	}

	offset := 0
	if params.Offset != nil {
		offset = *params.Offset
	}

  var b sq.SelectBuilder
  switch r.placeholder {
	case DollarWildcard:
	  b = sq.Select(
		{{- range .Fields }}
		Column{{$.MessageName}}{{.Name}},
		{{- end }}
	  ).From(Table{{.MessageName}}).PlaceholderFormat(sq.Dollar)
  default:
	  b = sq.Select(
		{{- range .Fields }}
		Column{{$.MessageName}}{{.Name}},
		{{- end }}
	  ).From(Table{{.MessageName}}).PlaceholderFormat(sq.Question)
  }

	f := &Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](f)
	}
	b = ApplyWhere(b, *f)

	return &Cursor{
		pool:      r.runner,
		builder:   b,
		rows:      make([]{{.MessageName}}, 0, limit),
		index:    -1,
		offset:   offset,
		limit:    limit,
		params:   params,
		ctx:      ctx,
		totalRows: 0,
		closed:    false,
	}
}

func (c *Cursor) fetchRows() error {
	if c.closed {
		return errors.New("cursor is closed")
	}

	// Check if we've reached the maximum number of rows
	if c.params.MaxRows != nil && c.totalRows >= *c.params.MaxRows {
		return nil // No more rows to fetch
	}
	builder := c.builder

	if c.params.SearchCol != nil && c.params.SearchTerm != nil {
		builder = builder.Where(sq.ILike{*c.params.SearchCol: fmt.Sprintf("%%%s%%", *c.params.SearchTerm)})
	}

	if c.params.OrderBy != nil {
		builder = builder.OrderBy(*c.params.OrderBy)
	}
	remainingRows := c.limit
	if c.params.MaxRows != nil {
		remainingRows = *c.params.MaxRows - c.totalRows
		if remainingRows <= 0 {
			return nil 		
		}
		if remainingRows > c.limit {
			remainingRows = c.limit
		}
	}

	builder = builder.Limit(uint64(remainingRows)).Offset(uint64(c.offset))

	sql, args, err := builder.ToSql()
	if err != nil {
		return err
	}

	rows, err := c.pool.QueryContext(c.ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	c.rows = make([]{{.MessageName}}, 0,c.limit)
	for rows.Next() {
		var item {{.MessageName}}
		err := rows.Scan(
		{{- range .Fields }}
			&item.{{.Name}},
		{{- end }}
		)
		if err != nil {
			return fmt.Errorf("error scanning row: %w", err)
		}
		c.totalRows++
		c.rows = append(c.rows, item)
	}

	if len(c.rows) > 0 {
		c.offset += remainingRows
	}
	return nil
}

func (c *Cursor) Next() bool {
	if c.closed {
		return false
	}

	// Check if we've reached the maximum number of rows
	if c.params.MaxRows != nil && c.totalRows >= *c.params.MaxRows && c.index >= len(c.rows)-1 {
		return false
	}
	if c.index >= len(c.rows)-1 {
		if err := c.fetchRows(); err != nil || len(c.rows) == 0 {
			return false
		}
		c.index = 0
		return true
	}

	c.index++
	return true
}

func (c *Cursor) Prev() bool {
	if c.closed {
		return false
	}
	if c.index > 0 {
		c.index--
		return true
	}
	return false
}

func (c *Cursor) Current() ({{.MessageName}}, error) {
	if c.closed {
		return {{.MessageName}}{}, errors.New("cursor is closed")
	}

	if c.index >= 0 && c.index < len(c.rows) {
		return c.rows[c.index], nil
	}
	return {{.MessageName}}{} , errors.New("not found")
}

func (c *Cursor) Reset() {
	if c.closed {
		return
	}

	c.index = -1
	c.offset = 0
	c.totalRows = 0
	c.rows = c.rows[:0] // Clear the slice while keeping the underlying array
}

// Close releases all resources held by the cursor.
func (c *Cursor) Close() {
	if c.closed {
		return
	}

	c.rows = nil // Free the memory held by the rows slice
	c.closed = true
}
