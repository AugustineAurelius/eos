//Code generated by generator, DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	{{- if .HasIDField}}
	{{- if or (eq .IDType "uuid.UUID") (eq .IDType "*uuid.UUID")}}
	"github.com/google/uuid"
	{{- end}}
	{{- end}}

	"github.com/AugustineAurelius/eos/pkg/generics"
	sq "github.com/Masterminds/squirrel"
	{{- range .Imports }}
	{{ . }}
	{{- end }}
)

type querier interface {
    ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
    QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
    QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

type wildcard int

const (
	QuestionWildcard wildcard = iota + 1
	DollarWildcard
)

type CommandRepository struct{
	runner querier
  	placeholder wildcard 
}

type QueryRepository struct{
	runner querier
  	placeholder wildcard 
}

func NewCommand(db querier, wildcards ...wildcard) *CommandRepository {
	w := QuestionWildcard 
	if len(wildcards) >0 {
		w = wildcards[0]
	}

	return &CommandRepository{
		runner: db,
    placeholder: w,
	}
}

func NewQuery(db querier, wildcards ...wildcard) *QueryRepository {
  	w := QuestionWildcard 
  	if len(wildcards) >0 {
    	w = wildcards[0]
  	}

	return &QueryRepository{
	    runner: db,
      	placeholder: w,
	}
}

// {{.MessageName}}Filer represents the {{.MessageName}} filter.
type Filter struct {
{{- range .Fields }}
	{{.Name | lower}} *{{.Type}}
	not{{.Name | lower}} *{{.Type}}
	gt{{.Name | lower}} *{{.Type}}
	lt{{.Name | lower}} *{{.Type}}
	gteq{{.Name | lower}} *{{.Type}}
	lteq{{.Name | lower}} *{{.Type}}
	{{.Name | lower}}s []{{.Type}}
	{{.Name | lower}}orderByAsc  *string
	{{.Name | lower}}orderByDesc *string
{{- end }}
	limit *int
	offset *int

}

type FilterOpt func(f *Filter)

func NewFilter(opts ...FilterOpt) Filter{
	f := Filter{}
	for _, opt := range opts {
		opt(&f)
	}
	return f
}

func WithLimit(limit int)  FilterOpt {
	c := limit
	return func(f *Filter) {
		f.limit = &c
	}
}
func WithOffset(offset int)  FilterOpt {
	c := offset
	return func(f *Filter) {
		f.offset = &c
	}
}

{{- range .Fields }}
func With{{.Name}}({{.Name | lower}} {{.Type}})  FilterOpt {
	c := {{.Name | lower}}
	return func(f *Filter) {
		f.{{.Name | lower}} = &c
	}
}
func With{{.Name}}Not({{.Name | lower}} {{.Type}})  FilterOpt {
	c := {{.Name | lower}}
	return func(f *Filter) {
		f.not{{.Name | lower}} = &c
	}
}
func With{{.Name}}MoreThen({{.Name | lower}} {{.Type}})  FilterOpt {
	c := {{.Name | lower}}
	return func(f *Filter) {
		f.gt{{.Name | lower}} = &c
	}
}
func With{{.Name}}LowerThen({{.Name | lower}} {{.Type}})  FilterOpt {
	c := {{.Name | lower}}
	return func(f *Filter) {
		f.lt{{.Name | lower}} = &c
	}
}
func With{{.Name}}MoreOrEqualThen({{.Name | lower}} {{.Type}})  FilterOpt {
	c := {{.Name | lower}}
	return func(f *Filter) {
		f.gteq{{.Name | lower}} = &c
	}
}
func With{{.Name}}LowerOrEqualThen({{.Name | lower}} {{.Type}})  FilterOpt {
	c := {{.Name | lower}}
	return func(f *Filter) {
		f.lteq{{.Name | lower}} = &c
	}
}
func With{{.Name}}s ({{.Name | lower}}s ...{{.Type}})  FilterOpt {
	return func(f *Filter) {
		f.{{.Name | lower}}s = append(f.{{.Name | lower}}s, {{.Name | lower}}s...)
	}
}

func WithOrderBy{{.Name}}Asc()  FilterOpt {
	return func(f *Filter) {
		var column string = "{{.Column | snakeCase}} ASC"
		f.{{.Name | lower}}orderByAsc =&column
	}
}
func WithOrderBy{{.Name}}Desc()  FilterOpt {
	return func(f *Filter) {
		var column string = "{{.Column | snakeCase}} DESC"
		f.{{.Name | lower}}orderByDesc =&column
	}
}
{{- end }}

func applyWhere[B interface {
    Where(pred interface{}, args ...interface{}) B
	Limit(limit uint64) B
	Offset(limit uint64) B
	OrderBy(orderBys ...string) B
}](b B,f *Filter) B {
  {{- range .Fields }}
	if f.{{.Name | lower}} != nil {
      b = b.Where(sq.Eq{Column{{$.MessageName}}{{.Name}}: *f.{{.Name | lower}}})
    }
	if f.not{{.Name | lower}} != nil {
      b = b.Where(sq.NotEq{Column{{$.MessageName}}{{.Name}}: *f.not{{.Name | lower}}})
    }
	if f.lt{{.Name | lower}} != nil {
      b = b.Where(sq.Lt{Column{{$.MessageName}}{{.Name}}: *f.lt{{.Name | lower}}})
    }
	if f.gt{{.Name | lower}} != nil {
      b = b.Where(sq.Gt{Column{{$.MessageName}}{{.Name}}: *f.gt{{.Name | lower}}})
    }
	if f.lteq{{.Name | lower}} != nil {
      b = b.Where(sq.LtOrEq{Column{{$.MessageName}}{{.Name}}: *f.lteq{{.Name | lower}}})
    }
	if f.gteq{{.Name | lower}} != nil {
      b = b.Where(sq.GtOrEq{Column{{$.MessageName}}{{.Name}}: *f.gteq{{.Name | lower}}})
    }
	if f.{{.Name | lower}}s != nil {
      b = b.Where(sq.Eq{Column{{$.MessageName}}{{.Name}}: f.{{.Name | lower}}s})
    }
	if f.{{.Name | lower}}orderByAsc != nil {
		b =b.OrderBy(*f.{{.Name | lower}}orderByAsc)
	}
	if f.{{.Name | lower}}orderByDesc != nil {
		b =b.OrderBy(*f.{{.Name | lower}}orderByDesc)
	}
  {{- end }}

	if f.limit != nil {
		b  = b.Limit(uint64(*f.limit))
	}
	if f.offset != nil {
		b  = b.Offset(uint64(*f.offset))
	}

  return b
}

type UpdateOpt func(u *Update)

// {{.MessageName}}Update represents the {{.MessageName}} update struct.
type Update struct {
{{- range .Fields }}
  {{.Name | lower}} *{{.Type}}
{{- end }}
}

func NewUpdate(opts ...UpdateOpt) Update{
	u := &Update{}
	for _, opt := range opts {
		opt(u)
	}
	return *u
}

{{- range .Fields }}
func WithUpdate{{.Name}}({{.Name | lower}} {{.Type}})  UpdateOpt {
	return func(f *Update) {
		f.{{.Name | lower}} = &{{.Name | lower}}
	}
}
{{- end }}

func applySet[B interface {
    Set(column string, value interface{}) B
}] (b B, f *Update) B {
  {{- range .Fields }}
	if f.{{.Name | lower}} != nil {
      b = b.Set(Column{{$.MessageName}}{{.Name}}, *f.{{.Name | lower}})
    }
  {{- end }}

  return b
}

// Create{{.MessageName}} inserts a new {{.MessageName}} into the database.
func (r *CommandRepository) Create(ctx context.Context, model *{{.MessageName}}) error {
  	var query string
  	var args []any
  
	switch r.placeholder {
	case DollarWildcard:
		query, args = sq.Insert(Table{{.MessageName}}).Columns({{- .Fields | columns_create -}}).Values({{- .Fields | values_create -}}). PlaceholderFormat(sq.Dollar).MustSql()
  	default:
		query, args = sq.Insert(Table{{.MessageName}}).Columns({{- .Fields | columns_create -}}).Values({{- .Fields | values_create -}}).PlaceholderFormat(sq.Question).MustSql()	
  	}

	if _, err := r.runner.ExecContext(ctx, query, args...); err != nil {
		return fmt.Errorf("failed to exec create query %s with args %v error = %w", query, args, err)
	}
	return nil
}

// CreateMany{{.MessageName}} inserts multiple {{.MessageName}}s into the database.
func (r *CommandRepository) CreateMany(ctx context.Context, {{.MessageName | lower}}s []{{.MessageName}}) error {
  	var builder sq.InsertBuilder

	switch r.placeholder {
	case DollarWildcard:
	  	builder = sq.Insert(Table{{.MessageName}}).Columns({{.Fields | columns_create -}}).PlaceholderFormat(sq.Dollar)
  	default:
	  	builder = sq.Insert(Table{{.MessageName}}).Columns({{.Fields | columns_create -}}).PlaceholderFormat(sq.Question)
  	}

  	for _, model := range {{.MessageName | lower}}s {
    	builder = builder.Values({{- .Fields | values_create -}})
  	}
	query, args := builder.MustSql()

	if _, err := r.runner.ExecContext(ctx, query, args...); err != nil {
		return fmt.Errorf("failed to exec create query %s with args %v error = %w", query, args, err)
	}
	return nil
}

// Update{{.MessageName}} updates an existing {{.MessageName}} in the database.
func (r *CommandRepository) Update(ctx context.Context, u Update, opts ...FilterOpt) error {
  	var b sq.UpdateBuilder
	switch r.placeholder {
	case DollarWildcard:
	  	b = sq.Update(Table{{.MessageName}}).PlaceholderFormat(sq.Dollar)
  	default:
	  	b = sq.Update(Table{{.MessageName}}).PlaceholderFormat(sq.Question)
  	}

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)
  	b = applySet(b, &u)

	query, args := b.MustSql()
	if _, err := r.runner.ExecContext(ctx, query, args...); err != nil {
		return fmt.Errorf("failed to exec update query %s with args %v", query, args)
	}
	return nil 
}

// Upsert{{.MessageName}} inserts a new {{.MessageName}} or updates an existing one.
func (r *CommandRepository) Upsert(ctx context.Context, model *{{.MessageName}}) error {
	var query string
	var args []any

	switch r.placeholder {
	case DollarWildcard:
		query, args = sq.Insert(Table{{.MessageName}}).
			Columns({{- .Fields | columns_create -}}).
			Values({{- .Fields | values_create -}}).
			Suffix("ON CONFLICT (id) DO UPDATE SET {{ $hasNonIDFields := false -}}{{- range .Fields -}}{{- if ne .Name "ID" -}}{{- $hasNonIDFields = true -}}{{- end -}}{{- end -}}{{- if $hasNonIDFields}} {{- $first := true -}}{{- range .Fields -}}{{if ne .Name "ID"}}{{if not $first}}, {{end}}{{.Column | snakeCase}} = EXCLUDED.{{.Column | snakeCase}}{{- $first = false -}}{{end}}{{end}}{{- end}}").
			PlaceholderFormat(sq.Dollar).
			MustSql()
	default:
		query, args = sq.Insert(Table{{.MessageName}}).
			Columns({{- .Fields | columns_create -}}).
			Values({{- .Fields | values_create -}}).
			Suffix("ON CONFLICT (id) DO UPDATE SET {{ $hasNonIDFields := false -}}{{- range .Fields -}}{{- if ne .Name "ID" -}}{{- $hasNonIDFields = true -}}{{- end -}}{{- end -}}{{- if $hasNonIDFields}} {{- $first := true -}}{{- range .Fields -}}{{if ne .Name "ID"}}{{if not $first}}, {{end}}{{.Column | snakeCase}} = EXCLUDED.{{.Column | snakeCase}}{{- $first = false -}}{{end}}{{end}}{{- end}}").
			PlaceholderFormat(sq.Question).
			MustSql()
	}

	if _, err := r.runner.ExecContext(ctx, query, args...); err != nil {
		return fmt.Errorf("failed to exec upsert query %s with args %v error = %w", query, args, err)
	}
	return nil
}

{{- if and .HasIDField .SupportsSave}}
// Save{{.MessageName}} saves a {{.MessageName}} (creates if ID is zero, updates otherwise).
func (r *CommandRepository) Save(ctx context.Context, model *{{.MessageName}}) error {
	{{- if .WithDefaultID}}
	{{- if eq .IDType "int" "int8" "int16" "int32" "int64" "uint" "uint8" "uint16" "uint32" "uint64" "uintptr" "float32" "float64"}}
	if model.ID == 0 {
	{{- else if eq .IDType "string"}}
	if model.ID == "" {
	{{- else if eq .IDType "uuid.UUID"}}
	if model.ID == uuid.Nil {
	{{- else if eq .IDType "*int" "*int8" "*int16" "*int32" "*int64" "*uint" "*uint8" "*uint16" "*uint32" "*uint64" "*uintptr" "*float32" "*float64"}}
	if model.ID == nil {
	{{- else if eq .IDType "*string"}}
	if model.ID == nil {
	{{- else if eq .IDType "*uuid.UUID"}}
	if model.ID == nil {
	{{- end}}
		return r.Create(ctx, model)
	}
	{{- $hasNonIDFields := false -}}
	{{- range .Fields -}}
	{{- if ne .Name "ID" -}}
	{{- $hasNonIDFields = true -}}
	{{- end -}}
	{{- end -}}
	{{- if $hasNonIDFields}}
	return r.Update(ctx, NewUpdate({{- $first := true -}}{{- range .Fields -}}{{if ne .Name "ID"}}{{if not $first}}, {{end}}WithUpdate{{.Name}}(model.{{.Name}}){{- $first = false -}}{{end}}{{end}}), WithID(model.ID))
	{{- else}}
	return r.Update(ctx, NewUpdate(), WithID(model.ID))
	{{- end}}
	{{- else}}
	// Check if record exists by trying to get it
	_, err := r.Get(ctx, WithID(model.ID))
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			// If not found, create new record
			return r.Create(ctx, model)
		}
		// If other error occurred, return it
		return err
	}
	// If found, update existing record
	{{- $hasNonIDFields := false -}}
	{{- range .Fields -}}
	{{- if ne .Name "ID" -}}
	{{- $hasNonIDFields = true -}}
	{{- end -}}
	{{- end -}}
	{{- if $hasNonIDFields}}
	return r.Update(ctx, NewUpdate({{- $first := true -}}{{- range .Fields -}}{{if ne .Name "ID"}}{{if not $first}}, {{end}}WithUpdate{{.Name}}(model.{{.Name}}){{- $first = false -}}{{end}}{{end}}), WithID(model.ID))
	{{- else}}
	return r.Update(ctx, NewUpdate(), WithID(model.ID))
	{{- end}}
	{{- end}}
}
{{- end}}

// Delete{{.MessageName}} deletes {{.MessageName}}s from the database.
func (r *CommandRepository) Delete(ctx context.Context, opts ...FilterOpt) error {
	var b sq.DeleteBuilder
	switch r.placeholder {
	case DollarWildcard:
		b = sq.Delete(Table{{.MessageName}}).PlaceholderFormat(sq.Dollar)
	default:
		b = sq.Delete(Table{{.MessageName}}).PlaceholderFormat(sq.Question)
	}

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

	query, args := b.MustSql()
	if _, err := r.runner.ExecContext(ctx, query, args...); err != nil {
		return fmt.Errorf("failed to exec delete query %s with args %v", query, args)
	}
	return nil
}

// Get{{.MessageName}} retrieves a single {{.MessageName}} from the database.
func (r *CommandRepository) Get(ctx context.Context, opts ...FilterOpt) (*{{.MessageName}}, error) {
	return get(ctx, r.runner, r.placeholder, opts...)
}

func (r *QueryRepository) Get(ctx context.Context, opts ...FilterOpt) (*{{.MessageName}}, error) {
	return get(ctx, r.runner, r.placeholder, opts...)
}

func get(ctx context.Context, run querier, placeholder wildcard, opts ...FilterOpt) (*{{.MessageName}}, error){
  	var b sq.SelectBuilder

	switch placeholder {
	case DollarWildcard:
		b = sq.Select({{- .Fields | columns -}}).From(Table{{.MessageName}}).PlaceholderFormat(sq.Dollar)
	default:
		b = sq.Select({{- .Fields | columns -}}).From(Table{{.MessageName}}).PlaceholderFormat(sq.Question)
	}
  
	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

  	query, args := b.MustSql()

	var model {{.MessageName}}
	err := run.QueryRowContext(ctx, query, args...).Scan({{- .Fields | scan }})
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("{{.MessageName | lower}} not found")
		}
		return nil, fmt.Errorf("failed to get query %s with args %v error = %w" , query, args, err)
	}

	return &model, err
}

// GetMany{{.MessageName}} retrieves multiple {{.MessageName}}s from the database.
func (r *CommandRepository) GetMany(ctx context.Context, opts ...FilterOpt) (generics.SliceOps[{{.MessageName}}], error) {
	return getMany(ctx, r.runner, r.placeholder, opts...)
}

func (r *QueryRepository) GetMany(ctx context.Context, opts ...FilterOpt) (generics.SliceOps[{{.MessageName}}], error) {
	return getMany(ctx, r.runner, r.placeholder, opts...)
}

func getMany(ctx context.Context, run querier, placeholder wildcard,  opts ...FilterOpt) (generics.SliceOps[{{.MessageName}}], error) {
  	var b sq.SelectBuilder

	switch placeholder {
	case DollarWildcard:
		b = sq.Select({{- .Fields | columns -}}).From(Table{{.MessageName}}).PlaceholderFormat(sq.Dollar)  
	default:
		b = sq.Select({{- .Fields | columns -}}).From(Table{{.MessageName}}).PlaceholderFormat(sq.Question)
	}

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

 	query, args := b.MustSql()

  	var {{.MessageName | lower}}s generics.SliceOps[{{.MessageName}}]
	rows, err := run.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("error querying database: %w", err)
	}
	defer rows.Close()

	var model {{.MessageName}}
	for rows.Next() {
		err = rows.Scan({{- .Fields | scan -}})
		if err != nil {
			return nil, fmt.Errorf("error scanning row: %w", err)
		}
		{{.MessageName | lower}}s = append({{.MessageName | lower}}s, model)
	}

	if rows.Err() != nil {
		return nil, fmt.Errorf("error iterating rows: %w", rows.Err())
	}

	return {{.MessageName | lower}}s, err
}

// Has{{.MessageName}} checks if a {{.MessageName}} exists in the database.
func (r *CommandRepository) Has(ctx context.Context, opts ...FilterOpt) (bool, error) {
	return has(ctx, r.runner, r.placeholder, opts...)
}

func (r *QueryRepository) Has(ctx context.Context, opts ...FilterOpt) (bool, error) {
	return has(ctx, r.runner, r.placeholder, opts...)
}

func has(ctx context.Context, run querier, placeholder wildcard, opts ...FilterOpt) (bool, error) {
	var b sq.SelectBuilder

	switch placeholder {
	case DollarWildcard:
		b = sq.Select("1").From(Table{{.MessageName}}).PlaceholderFormat(sq.Dollar)
	default:
		b = sq.Select("1").From(Table{{.MessageName}}).PlaceholderFormat(sq.Question)
	}

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)
	b = b.Limit(1)

	query, args := b.MustSql()

	var exists int
	err := run.QueryRowContext(ctx, query, args...).Scan(&exists)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return false, nil
		}
		return false, fmt.Errorf("failed to check existence query %s with args %v error = %w", query, args, err)
	}

	return true, nil
}

// GetIterator{{.MessageName}} returns an iterator for {{.MessageName}}s.
func (r *CommandRepository) GetIterator(ctx context.Context, opts ...FilterOpt) generics.IterWithErr[{{.MessageName}}] {
	return getIterator(ctx, r.runner, r.placeholder, opts...)
}

func (r *QueryRepository) GetIterator(ctx context.Context, opts ...FilterOpt) generics.IterWithErr[{{.MessageName}}] {
	return getIterator(ctx, r.runner, r.placeholder, opts...)
}

func getIterator(ctx context.Context, run querier, placeholder wildcard, opts ...FilterOpt) generics.IterWithErr[{{.MessageName}}] {
	return func(yield func({{.MessageName}}, error) bool) {
		pageSize := 100
		offset := 0

		f := Filter{}
		for i := 0; i < len(opts); i++ {
			opts[i](&f)
		}

		if f.limit != nil && *f.limit > 0 {
			pageSize = *f.limit
		}

		for {
			pageOpts := make([]FilterOpt, 0, len(opts)+2)
			pageOpts = append(pageOpts, opts...)
			pageOpts = append(pageOpts, WithLimit(pageSize))
			pageOpts = append(pageOpts, WithOffset(offset))

			{{.MessageName | lower}}s, err := getMany(ctx, run, placeholder, pageOpts...)
			if err != nil {
				yield({{.MessageName}}{}, err)
				return
			}

			if len({{.MessageName | lower}}s) == 0 {
				break
			}

			for _, {{.MessageName | lower}} := range {{.MessageName | lower}}s {
				if !yield({{.MessageName | lower}}, nil) {
					return
				}
			}

			if len({{.MessageName | lower}}s) < pageSize {
				break
			}

			offset += pageSize
		}
	}
}

// Count{{.MessageName}} counts {{.MessageName}}s in the database.
func (r *CommandRepository) Count(ctx context.Context, opts ...FilterOpt) (int, error) {
	return count(ctx, r.runner, r.placeholder, opts...)
}

func (r *QueryRepository) Count(ctx context.Context, opts ...FilterOpt) (int, error) {
	return count(ctx, r.runner, r.placeholder, opts...)
}

func count(ctx context.Context, run querier, placeholder wildcard, opts ...FilterOpt) (int, error) {
	var b sq.SelectBuilder

	switch placeholder {
	case DollarWildcard:
    	b = sq.Select("COUNT (1)").From(Table{{.MessageName}}).PlaceholderFormat(sq.Dollar)
	default:
    	b = sq.Select("COUNT (1)").From(Table{{.MessageName}}).PlaceholderFormat(sq.Question)
	}

  	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

  	query, args := b.MustSql()

  	var count int
  	err := run.QueryRowContext(ctx, query,args...).Scan(&count)
  	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return 0, nil
		}
    	return 0, fmt.Errorf("failed to count query %s with args %v error = %w" , query, args, err)
  	}

  	return count, nil
}


func (r *CommandRepository) NewCursor(ctx context.Context,  params BuilderParams, opts ...FilterOpt) *Cursor {
	limit := 10
	if params.Limit != nil {
		limit = *params.Limit
	}

	offset := 0
	if params.Offset != nil {
		offset = *params.Offset
	}
  var b sq.SelectBuilder
  switch r.placeholder {
	case DollarWildcard:
	  b = sq.Select(
		{{- range .Fields }}
		Column{{$.MessageName}}{{.Name}},
		{{- end }}
	  ).From(Table{{.MessageName}}).PlaceholderFormat(sq.Dollar)
  default:
	  b = sq.Select(
		{{- range .Fields }}
		Column{{$.MessageName}}{{.Name}},
		{{- end }}
	  ).From(Table{{.MessageName}}).PlaceholderFormat(sq.Question)
  }

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

	return &Cursor{
		pool:      r.runner,
		builder:   b,
		rows:      make([]{{.MessageName}}, 0, limit),
		index:    -1,
		offset:   offset,
		limit:    limit,
		params:   params,
		ctx:      ctx,
		totalRows: 0,
		closed:    false,
	}
}

func (r *QueryRepository) NewCursor(ctx context.Context,  params BuilderParams, opts ...FilterOpt) *Cursor {
	limit := 10
	if params.Limit != nil {
		limit = *params.Limit
	}

	offset := 0
	if params.Offset != nil {
		offset = *params.Offset
	}

  var b sq.SelectBuilder
  switch r.placeholder {
	case DollarWildcard:
	  b = sq.Select(
		{{- range .Fields }}
		Column{{$.MessageName}}{{.Name}},
		{{- end }}
	  ).From(Table{{.MessageName}}).PlaceholderFormat(sq.Dollar)
  default:
	  b = sq.Select(
		{{- range .Fields }}
		Column{{$.MessageName}}{{.Name}},
		{{- end }}
	  ).From(Table{{.MessageName}}).PlaceholderFormat(sq.Question)
  }

	f := Filter{}
	for i := 0; i < len(opts); i++ {
		opts[i](&f)
	}
	b = applyWhere(b, &f)

	return &Cursor{
		pool:      r.runner,
		builder:   b,
		rows:      make([]{{.MessageName}}, 0, limit),
		index:    -1,
		offset:   offset,
		limit:    limit,
		params:   params,
		ctx:      ctx,
		totalRows: 0,
		closed:    false,
	}
}

func (c *Cursor) fetchRows() error {
	if c.closed {
		return errors.New("cursor is closed")
	}

	// Check if we've reached the maximum number of rows
	if c.params.MaxRows != nil && c.totalRows >= *c.params.MaxRows {
		return nil // No more rows to fetch
	}
	builder := c.builder

	if c.params.SearchCol != nil && c.params.SearchTerm != nil {
		builder = builder.Where(sq.ILike{*c.params.SearchCol: fmt.Sprintf("%%%s%%", *c.params.SearchTerm)})
	}

	if c.params.OrderBy != nil {
		builder = builder.OrderBy(*c.params.OrderBy)
	}
	remainingRows := c.limit
	if c.params.MaxRows != nil {
		remainingRows = *c.params.MaxRows - c.totalRows
		if remainingRows <= 0 {
			return nil 		
		}
		if remainingRows > c.limit {
			remainingRows = c.limit
		}
	}

	builder = builder.Limit(uint64(remainingRows)).Offset(uint64(c.offset))

	sql, args, err := builder.ToSql()
	if err != nil {
		return err
	}

	rows, err := c.pool.QueryContext(c.ctx, sql, args...)
	if err != nil {
		return err
	}
	defer rows.Close()

	c.rows = make([]{{.MessageName}}, 0,c.limit)
	for rows.Next() {
		var item {{.MessageName}}
		err := rows.Scan(
		{{- range .Fields }}
			&item.{{.Name}},
		{{- end }}
		)
		if err != nil {
			return fmt.Errorf("error scanning row: %w", err)
		}
		c.totalRows++
		c.rows = append(c.rows, item)
	}

	if len(c.rows) > 0 {
		c.offset += remainingRows
	}
	return nil
}

func (c *Cursor) Next() bool {
	if c.closed {
		return false
	}

	// Check if we've reached the maximum number of rows
	if c.params.MaxRows != nil && c.totalRows >= *c.params.MaxRows && c.index >= len(c.rows)-1 {
		return false
	}
	if c.index >= len(c.rows)-1 {
		if err := c.fetchRows(); err != nil || len(c.rows) == 0 {
			return false
		}
		c.index = 0
		return true
	}

	c.index++
	return true
}

func (c *Cursor) Prev() bool {
	if c.closed {
		return false
	}
	if c.index > 0 {
		c.index--
		return true
	}
	return false
}

func (c *Cursor) Current() ({{.MessageName}}, error) {
	if c.closed {
		return {{.MessageName}}{}, errors.New("cursor is closed")
	}

	if c.index >= 0 && c.index < len(c.rows) {
		return c.rows[c.index], nil
	}
	return {{.MessageName}}{} , errors.New("not found")
}

func (c *Cursor) Reset() {
	if c.closed {
		return
	}

	c.index = -1
	c.offset = 0
	c.totalRows = 0
	c.rows = c.rows[:0] // Clear the slice while keeping the underlying array
}

// Close releases all resources held by the cursor.
func (c *Cursor) Close() {
	if c.closed {
		return
	}

	c.rows = nil // Free the memory held by the rows slice
	c.closed = true
}
