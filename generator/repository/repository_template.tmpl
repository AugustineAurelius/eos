//Code generated by generator, DO NOT EDIT.
package {{.PackageName}}

import (
	sq "github.com/Masterminds/squirrel"
	"sort"
	common "{{.CommonPath}}"
    {{- range .Imports }}
    {{ . }}
    {{- end }}
)


type CommandRepository struct{
	db common.Querier
}

type QueryRepository struct{
	db common.Querier
}

func NewCommand(db common.Querier) *CommandRepository {
	return &CommandRepository{
		db: db,
	}
}

func NewQuery(db common.Querier) *QueryRepository {
	return &QueryRepository{
		db: db,
	}
}

// {{.MessageName}}Filer represents the {{.MessageName}} filter.
type Filter struct {
{{- range .Fields }}
  {{.Name | lower}} *{{.Type}}
  not{{.Name | lower}} *{{.Type}}
  gt{{.Name | lower}} *{{.Type}}
  lt{{.Name | lower}} *{{.Type}}
  gteq{{.Name | lower}} *{{.Type}}
  lteq{{.Name | lower}} *{{.Type}}
  {{.Name | lower}}s []{{.Type}}
{{- end }}
}

type FilterOpt func(f *Filter)

func NewFilter(opts ...FilterOpt) Filter{
	f := &Filter{}
	for _, opt := range opts {
		opt(f)
	}
	return *f
}


{{- range .Fields }}
func With{{.Name}}({{.Name | lower}} {{.Type}})  FilterOpt {
	return func(f *Filter) {
		f.{{.Name | lower}} = &{{.Name | lower}}
	}
}
func With{{.Name}}Not({{.Name | lower}} {{.Type}})  FilterOpt {
	return func(f *Filter) {
		f.not{{.Name | lower}} = &{{.Name | lower}}
	}
}
func With{{.Name}}MoreThen({{.Name | lower}} {{.Type}})  FilterOpt {
	return func(f *Filter) {
		f.gt{{.Name | lower}} = &{{.Name | lower}}
	}
}
func With{{.Name}}LowerThen({{.Name | lower}} {{.Type}})  FilterOpt {
	return func(f *Filter) {
		f.lt{{.Name | lower}} = &{{.Name | lower}}
	}
}
func With{{.Name}}MoreOrEqualThen({{.Name | lower}} {{.Type}})  FilterOpt {
	return func(f *Filter) {
		f.gteq{{.Name | lower}} = &{{.Name | lower}}
	}
}
func With{{.Name}}LowerOrEqualThen({{.Name | lower}} {{.Type}})  FilterOpt {
	return func(f *Filter) {
		f.lteq{{.Name | lower}} = &{{.Name | lower}}
	}
}
func With{{.Name}}s ({{.Name | lower}}s ...{{.Type}})  FilterOpt {
	return func(f *Filter) {
		f.{{.Name | lower}}s = append(f.{{.Name | lower}}s, {{.Name | lower}}s...)
	}
}
{{- end }}

func ApplyWhere[B interface {
    Where(pred interface{}, args ...interface{}) B
}](b B,f Filter) B {
  {{- range .Fields }}
	if f.{{.Name | lower}} != nil {
      b = b.Where(sq.Eq{Column{{$.MessageName}}{{.Name}}: *f.{{.Name | lower}}})
    }
	if f.not{{.Name | lower}} != nil {
      b = b.Where(sq.NotEq{Column{{$.MessageName}}{{.Name}}: *f.{{.Name | lower}}})
    }
	if f.lt{{.Name | lower}} != nil {
      b = b.Where(sq.Lt{Column{{$.MessageName}}{{.Name}}: *f.{{.Name | lower}}})
    }
	if f.gt{{.Name | lower}} != nil {
      b = b.Where(sq.Gt{Column{{$.MessageName}}{{.Name}}: *f.{{.Name | lower}}})
    }
	if f.lteq{{.Name | lower}} != nil {
      b = b.Where(sq.LtOrEq{Column{{$.MessageName}}{{.Name}}: *f.{{.Name | lower}}})
    }
	if f.gteq{{.Name | lower}} != nil {
      b = b.Where(sq.GtOrEq{Column{{$.MessageName}}{{.Name}}: *f.{{.Name | lower}}})
    }
	if f.{{.Name | lower}}s != nil {
      b = b.Where(sq.Eq{Column{{$.MessageName}}{{.Name}}: f.{{.Name | lower}}s})
    }
  {{- end }}
  return b
}

type UpdateOpt func(u *Update)

// {{.MessageName}}Update represents the {{.MessageName}} update struct.
type Update struct {
{{- range .Fields }}
  {{.Name | lower}} *{{.Type}}
{{- end }}
}

func NewUpdate(opts ...UpdateOpt) Update{
	u := &Update{}
	for _, opt := range opts {
		opt(u)
	}
	return *u
}

{{- range .Fields }}
func WithUpdate{{.Name}}({{.Name | lower}} {{.Type}})  UpdateOpt {
	return func(f *Update) {
		f.{{.Name | lower}} = &{{.Name | lower}}
	}
}
{{- end }}

func ApplySet[B interface {
    Set(column string, value interface{}) B
}] (b B, f Update) B {
  {{- range .Fields }}
	if f.{{.Name | lower}} != nil {
      b = b.Set(Column{{$.MessageName}}{{.Name}}, *f.{{.Name | lower}})
    }
  {{- end }}

  return b
}

type {{.MessageName}}s []{{.MessageName}}

{{- range .Fields }}
func (s {{$.MessageName}}s) To{{.Name}}s ()  []{{.Type}} {
	output := make([]{{.Type}}, 0, len(s))
	for i := 0; i < len(s); i++{
    output = append(output, s[i].{{.Name}})
	}
	return output
}
{{- end }}


{{- range .Fields }}
	{{- if contains .Type "[]"}}
	{{- else}}
func (s {{$.MessageName}}s) FindBy{{.Name}} (finder {{.Type}})  ({{$.MessageName}}, bool) {
	for i := 0; i < len(s); i++{
		if s[i].{{.Name}}  == finder {
			return s[i], true 
		}
	}
	return   {{$.MessageName}} {}, false
}
{{- end }}
{{- end}}


{{- range .Fields }}
	{{- if contains .Type "[]"}}
	{{- else if contains .Type "time.Time"}}
func (s {{$.MessageName}}s) SortBy{{.Name}} (asc bool)  {{$.MessageName}}s {
	{{- if contains .Type "*"}}
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return s[i].{{.Name}}.Before( *s[j].{{.Name}})
		})
		return s
	}	
	sort.Slice(s, func(i, j int) bool {
		return s[i].{{.Name}}.After( *s[j].{{.Name}})
	})
	return  s
	{{- else}}
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return s[i].{{.Name}}.Before( s[j].{{.Name}})
		})
		return s
	}	
	sort.Slice(s, func(i, j int) bool {
		return s[i].{{.Name}}.After(s[j].{{.Name}})
	})
	return  s
	{{- end}}
}
	{{- else if contains .Type "bool"}}
	{{- else if contains .Type "."}}
	{{- else}}
func (s {{$.MessageName}}s) SortBy{{.Name}} (asc bool)  {{$.MessageName}}s {
	{{- if contains .Type "*"}}
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return *s[i].{{.Name}} < *s[j].{{.Name}}
		})
		return s
	}	
	sort.Slice(s, func(i, j int) bool {
		return *s[i].{{.Name}} > *s[j].{{.Name}}
	})
	return  s
	{{- else}}
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return s[i].{{.Name}} < s[j].{{.Name}}
		})
		return s
	}	
	sort.Slice(s, func(i, j int) bool {
		return s[i].{{.Name}} > s[j].{{.Name}}
	})
	return  s
	{{- end}}
}
	{{- end}}
{{- end }}




func (s {{$.MessageName}}s) FilterFunc(f func(i {{.MessageName}}) bool)  {{.MessageName}}s {
	output := make({{.MessageName}}s, 0, len(s))
	for i := 0; i < len(s); i++{ 
		if f(s[i]) {
			output = append(output, s[i])
		}
	}
	return output
}

{{- range .Fields }}
func (s {{$.MessageName}}s) GetFirst{{.Name}}()  (*{{.Type}}, bool) {
	if len(s) < 1 {
		return nil, false
	}
	return &s[0].{{.Name}}, true
}
{{- end }}



func (s {{$.MessageName}}s) GetFirst()  ({{.MessageName}}, bool) {
	if len(s) < 1 {
		return {{.MessageName}}{}, false
	}
	return s[0], true
}


