//Code generated by generator, DO NOT EDIT.
package {{.PackageName}}

import (
	sq "github.com/Masterminds/squirrel"
	"sort"
	common "{{.CommonPath}}"
    {{- range .Imports }}
    {{ . }}
    {{- end }}
)



type Repository struct{
	db common.Querier
}

func New(db common.Querier) *Repository {
	return &Repository{
		db: db,
	}
}

// {{.MessageName}}Filer represents the {{.MessageName}} filter.
type {{.MessageName}}Filter struct {
{{- range .Fields }}
  {{.Name | lower}} *{{.Type}}
  {{.Name | lower}}s []{{.Type}}
{{- end }}
}

func NewFilter() *{{.MessageName}}Filter{
	return &{{.MessageName}}Filter{}
}


{{- range .Fields }}
func (f *{{$.MessageName}}Filter) {{.Name}} ({{.Name | lower}} {{.Type}})  *{{$.MessageName}}Filter {
  f.{{.Name | lower}} = &{{.Name | lower}}
  return f
}

func (f *{{$.MessageName}}Filter) AddOneTo{{.Name}}s ({{.Name | lower}} {{.Type}})  *{{$.MessageName}}Filter {
  f.{{.Name | lower}}s = append(f.{{.Name | lower}}s, {{.Name | lower}})
  return f
}

func (f *{{$.MessageName}}Filter) {{.Name}}s ({{.Name | lower}}s []{{.Type}})  *{{$.MessageName}}Filter {
  f.{{.Name | lower}}s =  {{.Name | lower}}s
  return f
}
{{- end }}

func (f *{{$.MessageName}}Filter) Build()  {{$.MessageName}}Filter {
   return *f
}

func ApplyWhere[B interface {
    Where(pred interface{}, args ...interface{}) B
}](b B,f {{$.MessageName}}Filter) B {
  {{- range .Fields }}
	if f.{{.Name | lower}} != nil {
      b = b.Where(sq.Eq{Column{{$.MessageName}}{{.Name}}: *f.{{.Name | lower}}})
    }
	if f.{{.Name | lower}}s != nil {
      b = b.Where(sq.Eq{Column{{$.MessageName}}{{.Name}}: f.{{.Name | lower}}s})
    }
  {{- end }}
  return b
}

// {{.MessageName}}Update represents the {{.MessageName}} update struct.
type {{.MessageName}}Update struct {
{{- range .Fields }}
  {{.Name | lower}} *{{.Type}}
{{- end }}
}

func NewUpdate() *{{.MessageName}}Update{
	return &{{.MessageName}}Update{}
}

{{- range .Fields }}
func (u *{{$.MessageName}}Update) {{.Name}} ({{.Name | lower}} {{.Type}})  *{{$.MessageName}}Update {
  u.{{.Name | lower}} = &{{.Name | lower}}
  return u
}
{{- end }}

func (u *{{$.MessageName}}Update) Build()  {{$.MessageName}}Update {
  return *u
}

func ApplySet[B interface {
    Set(column string, value interface{}) B
}] (b B, f {{$.MessageName}}Update) B {
  {{- range .Fields }}
	if f.{{.Name | lower}} != nil {
      b = b.Set(Column{{$.MessageName}}{{.Name}}, *f.{{.Name | lower}})
    }
  {{- end }}

  return b
}

type {{.MessageName}}s []{{.MessageName}}

{{- range .Fields }}
func (s {{$.MessageName}}s) To{{.Name}}s ()  []{{.Type}} {
	output := make([]{{.Type}}, 0, len(s))
	for i := 0; i < len(s); i++{
    output = append(output, s[i].{{.Name}})
	}
	return output
}
{{- end }}


{{- range .Fields }}
	{{- if contains .Type "[]"}}
	{{- else}}
func (s {{$.MessageName}}s) FindBy{{.Name}} (finder {{.Type}})  ({{$.MessageName}}, bool) {
	for i := 0; i < len(s); i++{
		if s[i].{{.Name}}  == finder {
			return s[i], true 
		}
	}
	return   {{$.MessageName}} {}, false
}
{{- end }}
{{- end}}


{{- range .Fields }}
	{{- if contains .Type "[]"}}
	{{- else if contains .Type "time.Time"}}
func (s {{$.MessageName}}s) SortBy{{.Name}} (asc bool)  {{$.MessageName}}s {
	{{- if contains .Type "*"}}
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return *s[i].{{.Name}}.Before( *s[j].{{.Name}})
		})
		return s
	}	
	sort.Slice(s, func(i, j int) bool {
		return *s[i].{{.Name}}.After( *s[j].{{.Name}})
	})
	return  s
	{{- else}}
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return s[i].{{.Name}}.Before( s[j].{{.Name}})
		})
		return s
	}	
	sort.Slice(s, func(i, j int) bool {
		return s[i].{{.Name}}.After(s[j].{{.Name}})
	})
	return  s
	{{- end}}

	{{- else if contains .Type "."}}
	{{- else}}
func (s {{$.MessageName}}s) SortBy{{.Name}} (asc bool)  {{$.MessageName}}s {
	{{- if contains .Type "*"}}
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return *s[i].{{.Name}} < *s[j].{{.Name}}
		})
		return s
	}	
	sort.Slice(s, func(i, j int) bool {
		return *s[i].{{.Name}} > *s[j].{{.Name}}
	})
	return  s
	{{- else}}
	if asc {
		sort.Slice(s, func(i, j int) bool {
			return s[i].{{.Name}} < s[j].{{.Name}}
		})
		return s
	}	
	sort.Slice(s, func(i, j int) bool {
		return s[i].{{.Name}} > s[j].{{.Name}}
	})
	return  s
	{{- end}}
}
	{{- end}}
{{- end }}




func (s {{$.MessageName}}s) FilterFunc(f func(i {{.MessageName}}) bool)  {{.MessageName}}s {
	output := make({{.MessageName}}s, 0, len(s))
	for i := 0; i < len(s); i++{ 
		if f(s[i]) {
			output = append(output, s[i])
		}
	}
	return output
}


