//Code generated by generator, DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"database/sql"

	"github.com/AugustineAurelius/eos/pkg/generics"
	sq "github.com/Masterminds/squirrel"
	{{- range .Imports }}
	{{ . }}
	{{- end }}
)

type Query interface {
	Get(ctx context.Context, opts ...FilterOpt) (*{{.MessageName}}, error)
	GetMany(ctx context.Context, opts ...FilterOpt) (generics.SliceOps[{{.MessageName}}], error)
	Has(ctx context.Context, opts ...FilterOpt) (bool, error)
	GetIterator(ctx context.Context, opts ...FilterOpt) generics.IterWithErr[{{.MessageName}}]
	Count(ctx context.Context, opts ...FilterOpt) (int, error)
	NewCursor(ctx context.Context, params BuilderParams, opts ...FilterOpt) *Cursor
}

type Command interface {
	Query
	Create(ctx context.Context, model *{{.MessageName}}) error
	CreateMany(ctx context.Context, {{.MessageName | lower}}s []{{.MessageName}}) error
	Update(ctx context.Context, u Update, opts ...FilterOpt) error
	Delete(ctx context.Context, opts ...FilterOpt) error
}

type querier interface {
    ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
    QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
    QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

type wildcard int

const (
	QuestionWildcard wildcard = iota + 1
	DollarWildcard
)

type CommandRepository struct{
	runner querier
  	placeholder wildcard 
}

type QueryRepository struct{
	runner querier
  	placeholder wildcard 
}

func NewCommand(db querier, wildcards ...wildcard) *CommandRepository {
	w := QuestionWildcard 
	if len(wildcards) >0 {
		w = wildcards[0]
	}

	return &CommandRepository{
		runner: db,
    placeholder: w,
	}
}

func NewQuery(db querier, wildcards ...wildcard) *QueryRepository {
  	w := QuestionWildcard 
  	if len(wildcards) >0 {
    	w = wildcards[0]
  	}

	return &QueryRepository{
	    runner: db,
      	placeholder: w,
	}
}

// {{.MessageName}}Filer represents the {{.MessageName}} filter.
type Filter struct {
{{- range .Fields }}
	{{.Name | lower}} *{{.Type}}
	not{{.Name | lower}} *{{.Type}}
	gt{{.Name | lower}} *{{.Type}}
	lt{{.Name | lower}} *{{.Type}}
	gteq{{.Name | lower}} *{{.Type}}
	lteq{{.Name | lower}} *{{.Type}}
	{{.Name | lower}}s []{{.Type}}
	{{.Name | lower}}orderByAsc  *string
	{{.Name | lower}}orderByDesc *string
{{- end }}
	limit *int
	offset *int

}

type FilterOpt func(f *Filter)

func NewFilter(opts ...FilterOpt) Filter{
	f := Filter{}
	for _, opt := range opts {
		opt(&f)
	}
	return f
}

func WithLimit(limit int)  FilterOpt {
	c := limit
	return func(f *Filter) {
		f.limit = &c
	}
}
func WithOffset(offset int)  FilterOpt {
	c := offset
	return func(f *Filter) {
		f.offset = &c
	}
}

{{- range .Fields }}
func With{{.Name}}({{.Name | lower}} {{.Type}})  FilterOpt {
	c := {{.Name | lower}}
	return func(f *Filter) {
		f.{{.Name | lower}} = &c
	}
}
func With{{.Name}}Not({{.Name | lower}} {{.Type}})  FilterOpt {
	c := {{.Name | lower}}
	return func(f *Filter) {
		f.not{{.Name | lower}} = &c
	}
}
func With{{.Name}}MoreThen({{.Name | lower}} {{.Type}})  FilterOpt {
	c := {{.Name | lower}}
	return func(f *Filter) {
		f.gt{{.Name | lower}} = &c
	}
}
func With{{.Name}}LowerThen({{.Name | lower}} {{.Type}})  FilterOpt {
	c := {{.Name | lower}}
	return func(f *Filter) {
		f.lt{{.Name | lower}} = &c
	}
}
func With{{.Name}}MoreOrEqualThen({{.Name | lower}} {{.Type}})  FilterOpt {
	c := {{.Name | lower}}
	return func(f *Filter) {
		f.gteq{{.Name | lower}} = &c
	}
}
func With{{.Name}}LowerOrEqualThen({{.Name | lower}} {{.Type}})  FilterOpt {
	c := {{.Name | lower}}
	return func(f *Filter) {
		f.lteq{{.Name | lower}} = &c
	}
}
func With{{.Name}}s ({{.Name | lower}}s ...{{.Type}})  FilterOpt {
	return func(f *Filter) {
		f.{{.Name | lower}}s = append(f.{{.Name | lower}}s, {{.Name | lower}}s...)
	}
}

func WithOrderBy{{.Name}}Asc()  FilterOpt {
	return func(f *Filter) {
		var column string = "{{.Column | snakeCase}} ASC"
		f.{{.Name | lower}}orderByAsc =&column
	}
}
func WithOrderBy{{.Name}}Desc()  FilterOpt {
	return func(f *Filter) {
		var column string = "{{.Column | snakeCase}} DESC"
		f.{{.Name | lower}}orderByDesc =&column
	}
}
{{- end }}

func applyWhere[B interface {
    Where(pred interface{}, args ...interface{}) B
	Limit(limit uint64) B
	Offset(limit uint64) B
	OrderBy(orderBys ...string) B
}](b B,f *Filter) B {
  {{- range .Fields }}
	if f.{{.Name | lower}} != nil {
      b = b.Where(sq.Eq{Column{{$.MessageName}}{{.Name}}: *f.{{.Name | lower}}})
    }
	if f.not{{.Name | lower}} != nil {
      b = b.Where(sq.NotEq{Column{{$.MessageName}}{{.Name}}: *f.not{{.Name | lower}}})
    }
	if f.lt{{.Name | lower}} != nil {
      b = b.Where(sq.Lt{Column{{$.MessageName}}{{.Name}}: *f.lt{{.Name | lower}}})
    }
	if f.gt{{.Name | lower}} != nil {
      b = b.Where(sq.Gt{Column{{$.MessageName}}{{.Name}}: *f.gt{{.Name | lower}}})
    }
	if f.lteq{{.Name | lower}} != nil {
      b = b.Where(sq.LtOrEq{Column{{$.MessageName}}{{.Name}}: *f.lteq{{.Name | lower}}})
    }
	if f.gteq{{.Name | lower}} != nil {
      b = b.Where(sq.GtOrEq{Column{{$.MessageName}}{{.Name}}: *f.gteq{{.Name | lower}}})
    }
	if f.{{.Name | lower}}s != nil {
      b = b.Where(sq.Eq{Column{{$.MessageName}}{{.Name}}: f.{{.Name | lower}}s})
    }
	if f.{{.Name | lower}}orderByAsc != nil {
		b =b.OrderBy(*f.{{.Name | lower}}orderByAsc)
	}
	if f.{{.Name | lower}}orderByDesc != nil {
		b =b.OrderBy(*f.{{.Name | lower}}orderByDesc)
	}
  {{- end }}

	if f.limit != nil {
		b  = b.Limit(uint64(*f.limit))
	}
	if f.offset != nil {
		b  = b.Offset(uint64(*f.offset))
	}

  return b
}

type UpdateOpt func(u *Update)

// {{.MessageName}}Update represents the {{.MessageName}} update struct.
type Update struct {
{{- range .Fields }}
  {{.Name | lower}} *{{.Type}}
{{- end }}
}

func NewUpdate(opts ...UpdateOpt) Update{
	u := &Update{}
	for _, opt := range opts {
		opt(u)
	}
	return *u
}

{{- range .Fields }}
func WithUpdate{{.Name}}({{.Name | lower}} {{.Type}})  UpdateOpt {
	return func(f *Update) {
		f.{{.Name | lower}} = &{{.Name | lower}}
	}
}
{{- end }}

func applySet[B interface {
    Set(column string, value interface{}) B
}] (b B, f *Update) B {
  {{- range .Fields }}
	if f.{{.Name | lower}} != nil {
      b = b.Set(Column{{$.MessageName}}{{.Name}}, *f.{{.Name | lower}})
    }
  {{- end }}

  return b
}
