//Code generated by generator, DO NOT EDIT.
package {{.PackageName}}

import (
    "context"
    "errors"
    "fmt"

    "github.com/ClickHouse/go-clickhouse"
)

type ClickHouseConnectionProvider struct {
    ConnectionURL string
}

func (cp *ClickHouseConnectionProvider) GetConnectionURL() string {
    return cp.ConnectionURL
}

type ClickHouseDatabase struct {
    conn *clickhouse.Conn
}

func NewClickHouseDatabase(cp ConnectionProvider) (*ClickHouseDatabase, error) {
    conn, err := clickhouse.Connect(context.Background(), cp.GetConnectionURL())
    if err != nil {
        return nil, err
    }
    return &ClickHouseDatabase{
        conn: conn,
    }, nil
}

func (db *ClickHouseDatabase) Close() error {
    return db.conn.Close()
}

func (db *ClickHouseDatabase) Query(ctx context.Context, query string, args ...any) (rows, error) {
    stmt, err := db.conn.PrepareContext(ctx, query)
    if err != nil {
        return nil, err
    }
    defer stmt.Close()

    rowsIter, err := stmt.QueryContext(ctx, args...)
    if err != nil {
        return nil, err
    }
    return &ClickHouseRows{
        Iter: rowsIter,
    }, nil
}

func (db *ClickHouseDatabase) QueryRow(ctx context.Context, query string, args ...any) row {
    stmt, err := db.conn.PrepareContext(ctx, query)
    if err != nil {
        return &ClickHouseRow{
            err: err,
        }
    }
    defer stmt.Close()

    row := stmt.QueryRowContext(ctx, args...)
    return &ClickHouseRow{
        Row: row,
    }
}

func (db *ClickHouseDatabase) Exec(ctx context.Context, query string, args ...any) (result, error) {
    stmt, err := db.conn.PrepareContext(ctx, query)
    if err != nil {
        return nil, err
    }
    defer stmt.Close()

    res, err := stmt.ExecContext(ctx, args...)
    if err != nil {
        return nil, err
    }
    return &ClickHouseResult{
        Res: res,
    }, nil
}

func (db *ClickHouseDatabase) Begin(ctx context.Context) (Tx, error) {
    return nil, errors.New("ClickHouse does not support transactions")
}

type ClickHouseRows struct {
    Iter *clickhouse.Rows
    err  error
}

func (r *ClickHouseRows) Close() error {
    return r.Iter.Close()
}

func (r *ClickHouseRows) Err() error {
    return r.err
}

func (r *ClickHouseRows) Next() bool {
    return r.Iter.Next()
}

type ClickHouseRow struct {
    Row *clickhouse.Row
    err error
}

func (r *ClickHouseRow) Scan(dest ...any) error {
    if r.err != nil {
        return r.err
    }
    return r.Row.Scan(dest...)
}

type ClickHouseResult struct {
    Res *clickhouse.Result
}

func (r *ClickHouseResult) RowsAffected() (int64, error) {
    return r.Res.RowsAffected()
}

type ClickHouseTx struct{}

func (tx *ClickHouseTx) Query(ctx context.Context, query string, args ...any) (rows, error) {
    return nil, errors.New("transactions not supported")
}

func (tx *ClickHouseTx) QueryRow(ctx context.Context, query string, args ...any) row {
    return &ClickHouseRow{
        err: errors.New("transactions not supported"),
    }
}

func (tx *ClickHouseTx) Exec(ctx context.Context, query string, args ...any) (result, error) {
    return nil, errors.New("transactions not supported")
}

func (tx *ClickHouseTx) Commit(ctx context.Context) error {
    return errors.New("transactions not supported")
}

func (tx *ClickHouseTx) Rollback(ctx context.Context) error {
    return errors.New("transactions not supported")
}
